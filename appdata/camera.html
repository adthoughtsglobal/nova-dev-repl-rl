<!DOCTYPE html>
<html lang="en" ok>

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="nova-icon"
		content="<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='163.17529' height='127.21232' viewBox='0,0,163.17529,127.21232'><g transform='translate(-158.41236,-116.39385)'><g data-paper-data='{&quot;isPaintingLayer&quot;:true}' fill-rule='nonzero' stroke='none' stroke-linecap='butt' stroke-linejoin='miter' stroke-miterlimit='10' stroke-dasharray='' stroke-dashoffset='0' style='mix-blend-mode: normal'><path d='M158.41236,230.7239c0,-27.23223 0,-66.61583 0,-81.05088c0,-6.65115 6.83086,-13.41902 13.95578,-13.41902c4.91501,0 14.39739,0 26.30128,0c6.54386,0 13.8195,-19.86015 21.47043,-19.86015c13.61584,0 26.81,0 40.79382,0c6.11749,0 15.83525,19.86015 21.47043,19.86015c10.14999,0 17.09769,0 24.15424,0c9.27542,0 15.02931,6.15439 15.02931,12.3455c0,14.49323 0,55.50463 0,82.12441c0,7.90348 -5.94603,12.88225 -12.3455,12.88226c-18.21058,0 -104.59234,0 -136.874,0c-7.37038,0 -13.95578,-3.74802 -13.95578,-12.88226z' fill='rgb(69, 73, 97)' stroke-width='NaN'/><path d='M158.41236,175.43753c0,0 0,-11.32947 0,-25.76452c0,-6.65115 6.83086,-13.41902 13.95578,-13.41902c4.91501,0 14.39739,0 26.30128,0c6.54386,0 13.81949,-19.86015 21.47043,-19.86015c13.61584,0 26.81,0 40.79382,0c6.11749,0 15.83525,19.86015 21.47043,19.86015c10.14999,0 17.0977,0 24.15423,0c9.27542,0 15.02931,6.15439 15.02931,12.3455c0,14.49323 0,26.83805 0,26.83805z' fill='rgb(124, 136, 141)' stroke-width='NaN'/><path d='M196.25399,188.58817c0,-24.30847 19.70591,-44.01439 44.01439,-44.01439c24.30847,0 44.01439,19.70591 44.01439,44.01439c0,24.30847 -19.70591,44.01439 -44.01439,44.01439c-24.30847,0 -44.01439,-19.70591 -44.01439,-44.01439z' fill='#e3e3e3' stroke-width='0'/><path d='M207.52597,188.58817c0,-18.08313 14.65927,-32.74241 32.74241,-32.74241c18.08313,0 32.74241,14.65927 32.74241,32.74241c0,18.08313 -14.65927,32.74241 -32.74241,32.74241c-18.08313,0 -32.74241,-14.65927 -32.74241,-32.74241z' fill='#6d7e91' stroke-width='0'/><path d='M167.26891,155.57739c0,-5.03956 4.08537,-9.12493 9.12493,-9.12493c5.03956,0 9.12493,4.08537 9.12493,9.12493c0,5.03956 -4.08537,9.12493 -9.12493,9.12493c-5.03956,0 -9.12493,-4.08537 -9.12493,-9.12493z' fill='#ffffff' stroke-width='0'/></g></g></svg>">
	<title>Camera App</title>
	<style>
		body {
			display: flex;
			justify-content: center;
			align-items: stretch;
			flex-direction: row;
			margin: 0;
			height: calc(100vh - 5px);
			background-color: black;
			user-select: none;
		}

		.videopart {
			flex: 1;
		}

		.toolpart {
			width: fit-content;
			display: flex;
			flex-direction: column;
			justify-content: center;
			padding: 0.5rem;
			gap:0.5rem;
			background: #101010;
		}

		#video-container {

			width: 100%;
			height: 100%;
		}

		#video {
			height: 100%;
			border-radius: 0.5rem;
			object-fit: contain;
			width: 100%;
			transition: 0.2s ease-in-out;
		}

		.floattopnav {
			position: absolute;
			top: 10px;
			left: 10px;
			border-radius: 7px;
			padding: 4px;
			display: flex;
			gap: 3px;
			transition: 0.2s ease-out;
		}

		.floattopnav:hover {
			opacity: 1;
		}

		.floattopnav select {
			max-width: 130px;
			background-color: #7d7d7d;
			color: #d7d7d7;
			border: none;
			padding: 5px;
			overflow: hidden;
			opacity: 0.7;
			border-radius: 5px;
			text-overflow: ellipsis;
			display: inline-flex;
		}

		#mirror-btn,
		#flashlight-btn {
			padding: 4px 7px;
			aspect-ratio: 1 / 1;
			display: inline-grid;
			background-color: #7d7d7d;
			color: #fff;
			border: none;
			opacity: 0.7;
			border-radius: 5px;
			cursor: pointer;
			justify-items: center;
			align-items: center;
		}

		#mirror-btn span,
		#flashlight-btn span {
			font-size: 1rem !important;
			opacity: 1;
		}

		.captoolbtn {

			height: 15%;
			border: none;
			aspect-ratio: 1 / 1;
			display: grid;
			border-radius: 1rem;
			align-items: center;
			justify-items: center;
			background: #ffffff14;
			color: white;
		}

		.captoolbtn:active {
			transform: scale(0.9);
		}


		#timer {
			position: absolute;
			width: 100%;
			height: 100%;
			top: 0;
			left: 0;
			z-index: 2;
			font-size: 30vh;
			display: grid;
			justify-content: center;
			align-items: center;
			align-content: center;
			color: white;
			text-shadow: 0 0 1rem #0000007a;
			display: none;
		}

		@keyframes fade-in {
			0% {
				opacity: 0;
				transform: scale(0.8);
			}

			100% {
				opacity: 1;
				transform: scale(1);
			}
		}

		.timer-animate {
			animation: fade-in 0.5s ease-out;
		}
	</style>
	<meta name="nova-include" content="nova.css material-symbols-rounded">
</head>

<body>
	<div class="videopart">

		<div id="video-container">
			<video id="video" playsinline autoplay></video>
		</div>
		<div id="timer">
			3
		</div>
	</div>
	<div class="toolpart">
		<div class="floattopnav">
			<select id="camera-select"></select>
			<button id="mirror-btn" onclick="toggleMirror()"><span class="material-symbols-rounded">
					360
				</span></button>
			<button id="flashlight-btn" onclick="toggleFlashlight()"><span class="material-symbols-rounded">
					flash_on
				</span></button>
			<select id="timer-select">
				<option selected value="0">0s</option>
				<option value="2">3s</option>
				<option value="5">5s</option>
				<option value="10">10s</option>
			</select>
		</div>

		<button class="captoolbtn" id="photo-btn" onclick="capture(this)">
			<span class="material-symbols-rounded">camera</span>
		</button>
		<button class="captoolbtn" id="video-btn">
			<span class="material-symbols-rounded">videocam</span>
		</button>
		<button class="captoolbtn" id="pause-btn" style="display: none;">
			<span class="material-symbols-rounded">
				pause
				</span>
		<button class="captoolbtn" id="stop-btn" style="display: none;">
			<span class="material-symbols-rounded">stop</span></button>
	</div>
	<script>
		let isMirrored = false;
		let isFlashlightOn = false;
		let currentStream = null;
		let mediaRecorder;
		let recordedChunks = [];
		let isRecording = false;
		let isPaused = false;

		async function getVideoSources() {
			const devices = await navigator.mediaDevices.enumerateDevices();
			return devices.filter(device => device.kind === 'videoinput');
		}

		async function startCamera() {
			const video = document.getElementById('video');
			const cameras = await getVideoSources();
			const cameraSelect = document.getElementById('camera-select');

			if (cameras.length === 0) {
				console.error('No cameras found.');
				return;
			}

			cameraSelect.innerHTML = "";
			cameras.forEach(camera => {
				const option = document.createElement('option');
				option.value = camera.deviceId;
				option.text = camera.label || `Camera ${cameraSelect.length + 1}`;
				cameraSelect.appendChild(option);
			});

			cameraSelect.addEventListener('change', async () => {
				try {
					await startStream(cameraSelect.value);
					resetMirror();
				} catch (error) {
					console.error('Error accessing camera:', error);
				}
			});

			try {
				await startStream(cameras[0].deviceId);
			} catch (error) {
				console.error('Error accessing default camera:', error);
			}
		}

		async function startStream(deviceId) {
			const video = document.getElementById('video');
			if (currentStream) {
				currentStream.getTracks().forEach(track => track.stop());
			}
			const stream = await navigator.mediaDevices.getUserMedia({
				video: { deviceId: deviceId },
				audio: true
			});
			video.srcObject = stream;
			currentStream = stream;
		}

		function pauseRecording() {
			if (mediaRecorder && isRecording) {
				mediaRecorder.pause();
				isPaused = true;
				updateUI("paused");
			}
		}

		function resumeRecording() {
			if (mediaRecorder && isPaused) {
				mediaRecorder.resume();
				isPaused = false;
				updateUI("recording");
			}
		}

		function stopRecording() {
			if (mediaRecorder && isRecording) {
				mediaRecorder.stop();
				isRecording = false;
				updateUI("stopped");
			}
		}
		function createFile(blob, filename) {
			const a = document.createElement("a"); const videoURL = URL.createObjectURL(blob);
			console.log("Video URL:", videoURL);
			window.open(videoURL);
			a.href = url;
			a.download = filename;
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			URL.revokeObjectURL(url);
		}

		function updateUI(state) {
			const photoBtn = document.getElementById("photo-btn");
			const videoBtn = document.getElementById("video-btn");
			const pauseBtn = document.getElementById("pause-btn");
			const stopBtn = document.getElementById("stop-btn");

			if (state === "recording") {
				photoBtn.style.display = "none";
				videoBtn.style.display = "none";
				pauseBtn.style.display = "grid";
				stopBtn.style.display = "grid";
				pauseBtn.innerHTML = `
			<span class="material-symbols-rounded">
				pause
				</span>`;
			} else if (state === "paused") {
				pauseBtn.innerHTML = `
			<span class="material-symbols-rounded">
				play_arrow
				</span>`;
			} else if (state === "stopped") {
				photoBtn.style.display = "grid";
				videoBtn.style.display = "grid";
				pauseBtn.style.display = "none";
				stopBtn.style.display = "none";
			}
		}

		document.getElementById("video-btn").addEventListener("click", startRecording);
		document.getElementById("pause-btn").addEventListener("click", function () {
			if (isPaused) {
				resumeRecording();
			} else {
				pauseRecording();
			}
		});
		document.getElementById("stop-btn").addEventListener("click", stopRecording);

		function greenflag() {
			startCamera();
		}

		let timerelem = document.getElementById("timer");

		async function startStream(deviceId) {
			const video = document.getElementById('video');
			if (currentStream) {
				currentStream.getTracks().forEach(track => track.stop());
			}
			const stream = await navigator.mediaDevices.getUserMedia({
				video: { deviceId: deviceId },
				audio: true 
			});

			video.srcObject = new MediaStream(stream.getVideoTracks());
			currentStream = stream;
		}


		function startRecording() {
			if (!currentStream) {
				console.error("No active stream to record.");
				return;
			}

			recordedChunks = [];
			const options = { mimeType: "video/webm; codecs=vp9" };
			mediaRecorder = new MediaRecorder(currentStream, options);

			mediaRecorder.ondataavailable = (event) => {
				if (event.data && event.data.size > 0) {
					recordedChunks.push(event.data);
				}
			};

			mediaRecorder.onstop = saveRecording;

			mediaRecorder.start();
			isRecording = true;
			isPaused = false;

			updateUI("recording");
		}

		function saveRecording() {
			const blob = new Blob(recordedChunks, { type: recordedChunks[0].type || "video/webm" });

			function createFileWithTimestamp() {
				let now = new Date();
				let year = now.getFullYear();
				let month = String(now.getMonth() + 1).padStart(2, '0');
				let day = String(now.getDate()).padStart(2, '0');
				let hours = String(now.getHours()).padStart(2, '0');
				let minutes = String(now.getMinutes()).padStart(2, '0');

				let timestamp = `${year}-${month}-${day}, ${hours}:${minutes}`;
				let capturedString = `video_${timestamp} ${window.parent.genUID()}`;

				window.parent.createFile("Media/", capturedString, "webm", blob);
			}

			createFileWithTimestamp();
		}

		async function captureCameraImage() {
			const video = document.getElementById('video');
			const canvas = document.createElement('canvas');
			const ctx = canvas.getContext('2d');

			canvas.width = video.videoWidth;
			canvas.height = video.videoHeight;

			if (isMirrored) {
				ctx.translate(canvas.width, 0);
				ctx.scale(-1, 1);
			}

			ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

			var dataUrl;
			try {
				let qsets = await window.parent.getSetting("CamImgFormat");
				if (qsets) {
					dataUrl = canvas.toDataURL('image/' + qsets.toLowerCase() || 'webp');
				}
			} catch (error) {
				console.log("safe error: " + error);
			}

			return dataUrl;
		}

		async function capture(obj) {
			const video = document.getElementById('video');
			let cakebuff = obj.innerHTML;
			obj.innerHTML = "...";

			let timerValue = parseInt(document.getElementById('timer-select').value);
			timerelem.style.display = 'grid';

			if (isNaN(timerValue) || timerValue <= 0) {
				timerelem.textContent = "";
				video.style.display = "none";
				startCaptureProcess();
			} else {
				timerelem.textContent = timerValue + 1;

				let countdown = setInterval(() => {
					timerelem.textContent = timerValue;
					timerelem.classList.remove('timer-animate');
					void timerelem.offsetWidth;
					timerelem.classList.add('timer-animate');

					if (--timerValue < 0) {
						clearInterval(countdown);
						video.style.display = "none";
						timerelem.textContent = "";
						startCaptureProcess();
					}
				}, 1000);
			}

			async function startCaptureProcess() {
				try {
					let x = await captureCameraImage();
					x = window.parent.shrinkbsf(x);

					let FileFormat;
					let qsets = await window.parent.getSetting("CamImgFormat");
					if (qsets) {
						FileFormat = qsets.toLowerCase() || 'webm';
					}

					function createFileWithTimestamp() {
						let now = new Date();
						let year = now.getFullYear();
						let month = String(now.getMonth() + 1).padStart(2, '0');
						let day = String(now.getDate()).padStart(2, '0');
						let hours = String(now.getHours()).padStart(2, '0');
						let minutes = String(now.getMinutes()).padStart(2, '0');

						let timestamp = `${year}-${month}-${day}, ${hours}:${minutes}`;
						let capturedString = `captured_${timestamp} ${window.parent.genUID()}`;

						window.parent.createFile("Media/", capturedString, FileFormat, x);
					}

					createFileWithTimestamp();
					obj.innerHTML = cakebuff;

					setTimeout(() => {
						video.style.display = "block";
					}, 50);
				} catch (error) {
					console.log("Capture error:", error);
					obj.innerHTML = cakebuff;
				}

				timerelem.style.display = 'none';
			}
		}

	</script>
</body>

</html>