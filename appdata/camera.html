<!DOCTYPE html>
<html lang="en" ok>

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="nova-icon"
		content="<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='163.17529' height='127.21232' viewBox='0,0,163.17529,127.21232'><g transform='translate(-158.41236,-116.39385)'><g data-paper-data='{&quot;isPaintingLayer&quot;:true}' fill-rule='nonzero' stroke='none' stroke-linecap='butt' stroke-linejoin='miter' stroke-miterlimit='10' stroke-dasharray='' stroke-dashoffset='0' style='mix-blend-mode: normal'><path d='M158.41236,230.7239c0,-27.23223 0,-66.61583 0,-81.05088c0,-6.65115 6.83086,-13.41902 13.95578,-13.41902c4.91501,0 14.39739,0 26.30128,0c6.54386,0 13.8195,-19.86015 21.47043,-19.86015c13.61584,0 26.81,0 40.79382,0c6.11749,0 15.83525,19.86015 21.47043,19.86015c10.14999,0 17.09769,0 24.15424,0c9.27542,0 15.02931,6.15439 15.02931,12.3455c0,14.49323 0,55.50463 0,82.12441c0,7.90348 -5.94603,12.88225 -12.3455,12.88226c-18.21058,0 -104.59234,0 -136.874,0c-7.37038,0 -13.95578,-3.74802 -13.95578,-12.88226z' fill='rgb(69, 73, 97)' stroke-width='NaN'/><path d='M158.41236,175.43753c0,0 0,-11.32947 0,-25.76452c0,-6.65115 6.83086,-13.41902 13.95578,-13.41902c4.91501,0 14.39739,0 26.30128,0c6.54386,0 13.81949,-19.86015 21.47043,-19.86015c13.61584,0 26.81,0 40.79382,0c6.11749,0 15.83525,19.86015 21.47043,19.86015c10.14999,0 17.0977,0 24.15423,0c9.27542,0 15.02931,6.15439 15.02931,12.3455c0,14.49323 0,26.83805 0,26.83805z' fill='rgb(124, 136, 141)' stroke-width='NaN'/><path d='M196.25399,188.58817c0,-24.30847 19.70591,-44.01439 44.01439,-44.01439c24.30847,0 44.01439,19.70591 44.01439,44.01439c0,24.30847 -19.70591,44.01439 -44.01439,44.01439c-24.30847,0 -44.01439,-19.70591 -44.01439,-44.01439z' fill='#e3e3e3' stroke-width='0'/><path d='M207.52597,188.58817c0,-18.08313 14.65927,-32.74241 32.74241,-32.74241c18.08313,0 32.74241,14.65927 32.74241,32.74241c0,18.08313 -14.65927,32.74241 -32.74241,32.74241c-18.08313,0 -32.74241,-14.65927 -32.74241,-32.74241z' fill='#6d7e91' stroke-width='0'/><path d='M167.26891,155.57739c0,-5.03956 4.08537,-9.12493 9.12493,-9.12493c5.03956,0 9.12493,4.08537 9.12493,9.12493c0,5.03956 -4.08537,9.12493 -9.12493,9.12493c-5.03956,0 -9.12493,-4.08537 -9.12493,-9.12493z' fill='#ffffff' stroke-width='0'/></g></g></svg>">
	<title>Camera App</title>
	<style>
		body {
			display: flex;
			justify-content: center;
			align-items: stretch;
			flex-direction: row;
			margin: 0;
			height: calc(100vh - 5px);
			background-color: black;
			user-select:none;
		}

		.videopart {
			flex: 1;
		}

		.toolpart {
			width: fit-content;
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding: 0.5rem;
    background: #101010;
		}

		#video-container {
			
			width: 100%;
    height: 100%;
		}

		#video {
			height: 100%;
    border-radius: 0.5rem;
    object-fit: contain;
    width: 100%;
    transition: 0.2s ease-in-out;
		}

		.floattopnav {
			position: absolute;
    top: 10px;
    left: 10px;
    border-radius: 7px;
    padding: 4px;
    display: flex;
    gap: 3px;
    transition: 0.2s ease-out;
		}

		.floattopnav:hover {
			opacity: 1;
		}

		.floattopnav select {
			max-width: 130px;
    background-color: #7d7d7d;
    color: #d7d7d7;
    border: none;
    padding: 5px;
    overflow: hidden;
	opacity: 0.7;
    border-radius: 5px;
    text-overflow: ellipsis;
    display: inline-flex;
		}

		#mirror-btn,
		#flashlight-btn {
			padding: 4px 7px;
			aspect-ratio: 1 / 1;
			display: inline-grid;
			background-color: #7d7d7d;
			color: #fff;
			border: none;
			opacity: 0.7;
			border-radius: 5px;
			cursor: pointer;
			justify-items: center;
			align-items: center;
		}

		#mirror-btn span,
		#flashlight-btn span {
			font-size: 1rem !important;
			opacity: 1;
		}

		#photo-btn {
			
			height: 15%;
    border: none;
    aspect-ratio: 1 / 1;
    display: grid;
    border-radius: 1rem;
    align-items: center;
    justify-items: center;
    background: #ffffff14;
    color: white;
		}

		#photo-btn:active {
			transform: scale(0.9);
		}


		#timer {
			position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    z-index: 2;
    font-size: 30vh;
    display: grid;
    justify-content: center;
    align-items: center;
    align-content: center;
    color: white;
    text-shadow: 0 0 1rem #0000007a;
	display: none;
		}

		@keyframes fade-in {
    0% {
        opacity: 0;
        transform: scale(0.8);
    }
    100% {
        opacity: 1;
        transform: scale(1);
    }
}

.timer-animate {
    animation: fade-in 0.5s ease-out;
}
	</style>
	<meta name="nova-include" content="nova.css material-symbols-rounded">
</head>

<body>
	<div class="videopart">
		
	<div id="video-container">
		<video id="video" playsinline autoplay></video>
	</div>
	<div id="timer">
		3
	</div>
</div>
<div class="toolpart">
	<div class="floattopnav">
		<select id="camera-select"></select>
		<button id="mirror-btn" onclick="toggleMirror()"><span class="material-symbols-rounded">
				360
			</span></button>
		<button id="flashlight-btn" onclick="toggleFlashlight()"><span class="material-symbols-rounded">
				flash_on
			</span></button>
		<select id="timer-select">
			<option selected value="0">0s</option>
			<option value="2">3s</option>
			<option value="5">5s</option>
			<option value="10">10s</option>
		</select>
	</div>
	<button id="photo-btn" onclick="capture(this)"><span class="material-symbols-rounded">
			camera
		</span></button>
	</div>
	<script>
		let isMirrored = false;
		let isFlashlightOn = false;
		let currentStream = null;
		var timerelem = document.getElementById("timer");

		async function getVideoSources() {
			const devices = await navigator.mediaDevices.enumerateDevices();
			const cameras = devices.filter(device => device.kind === 'videoinput');
			return cameras;
		}

		async function startCamera() {
			const video = document.getElementById('video');
			const cameras = await getVideoSources();
			const cameraSelect = document.getElementById('camera-select');

			if (cameras.length === 0) {
				console.error('No cameras found.');
				return;
			}

			cameras.forEach(camera => {
				const option = document.createElement('option');
				option.value = camera.deviceId;
				option.text = camera.label || `Camera ${cameraSelect.length + 1}`;
				cameraSelect.appendChild(option);
			});

			cameraSelect.addEventListener('change', async () => {
				const selectedCameraId = cameraSelect.value;
				try {
					await startStream(selectedCameraId);
					resetMirror();
				} catch (error) {
					console.error('Error accessing camera:', error);
				}
			});

			const defaultCameraId = cameras[0].deviceId;
			try {
				await startStream(defaultCameraId);
			} catch (error) {
				console.error('Error accessing default camera:', error);
				let x = await window.parent.justConfirm("Can't Get Camera", "Your device seem to say that there's no camera, Should we try again harder?");
				if (x) {
					startCamera();
				}
			}
		}

		async function startStream(deviceId) {
			const video = document.getElementById('video');
			if (currentStream) {
				currentStream.getTracks().forEach(track => track.stop());
			}
			const stream = await navigator.mediaDevices.getUserMedia({
				video: {
					deviceId: deviceId,
					advanced: [{ torch: isFlashlightOn }]
				}
			});
			video.srcObject = stream;
			currentStream = stream;
		}

		function toggleMirror() {
			const video = document.getElementById('video');
			isMirrored = !isMirrored;
			video.style.transform = `scaleX(${isMirrored ? -1 : 1})`;
		}

		function resetMirror() {
			const video = document.getElementById('video');
			isMirrored = false;
			video.style.transform = 'scaleX(1)';
		}

		async function toggleFlashlight() {
			isFlashlightOn = !isFlashlightOn;
			const flashlightBtn = document.getElementById('flashlight-btn');
			flashlightBtn.innerHTML = `<span class="material-symbols-rounded">${isFlashlightOn ? 'flash_off' : 'flash_on'}</span>`;

			if (currentStream) {
				const track = currentStream.getVideoTracks()[0];
				try {
					await track.applyConstraints({
						advanced: [{ torch: isFlashlightOn }]
					});
				} catch (error) {
					console.error('Flashlight not supported:', error);
					window.parent.justConfirm("Flashlight Error", "It seems your device doesn't support flashlight control.");
				}
			}
		}

		function greenflag() {
			startCamera()
		}

		async function captureCameraImage() {
			const video = document.getElementById('video');
			const canvas = document.createElement('canvas');
			const ctx = canvas.getContext('2d');

			canvas.width = video.videoWidth;
			canvas.height = video.videoHeight;

			if (isMirrored) {
				ctx.translate(canvas.width, 0);
				ctx.scale(-1, 1);
			}

			ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

			var dataUrl;
			var condition = true;
			try {
				let qsets = await window.parent.getSetting("CamImgFormat");
				if (qsets) {
					if (qsets) {
						dataUrl = canvas.toDataURL('image/' + qsets.toLowerCase() || 'webp');
					}
				}
			} catch (error) {
				console.log("safe error: " + error);
			}

			return dataUrl;
		}

		async function capture(obj) {
    const video = document.getElementById('video');
    let cakebuff = obj.innerHTML;
    obj.innerHTML = "...";
    
    let timerValue = parseInt(document.getElementById('timer-select').value);
timerelem.style.display = 'grid';

if (isNaN(timerValue) || timerValue <= 0) {
    timerelem.textContent = "";
	video.style.display = "none";
    startCaptureProcess();
} else {
    timerelem.textContent = timerValue + 1;

    let countdown = setInterval(() => {
        timerelem.textContent = timerValue;
        timerelem.classList.remove('timer-animate');
        void timerelem.offsetWidth;
        timerelem.classList.add('timer-animate');

        if (--timerValue < 0) {
            clearInterval(countdown);
            video.style.display = "none";
            timerelem.textContent = "";
            startCaptureProcess();
        }
    }, 1000);
}

    async function startCaptureProcess() {
        try {
            let x = await captureCameraImage();
            x = window.parent.shrinkbsf(x);

            let FileFormat;
            let qsets = await window.parent.getSetting("CamImgFormat");
            if (qsets) {
                FileFormat = qsets.toLowerCase();
            }

            function createFileWithTimestamp() {
                let now = new Date();
                let year = now.getFullYear();
                let month = String(now.getMonth() + 1).padStart(2, '0');
                let day = String(now.getDate()).padStart(2, '0');
                let hours = String(now.getHours()).padStart(2, '0');
                let minutes = String(now.getMinutes()).padStart(2, '0');

                let timestamp = `${year}-${month}-${day}, ${hours}:${minutes}`;
                let capturedString = `captured_${timestamp} ${window.parent.genUID()}`;

                window.parent.createFile("Media/", capturedString, FileFormat, x);
            }

            createFileWithTimestamp();
            obj.innerHTML = cakebuff;

            setTimeout(() => {
                video.style.display = "block";
            }, 50);
        } catch (error) {
            console.log("Capture error:", error);
            obj.innerHTML = cakebuff;
        }

		timerelem.style.display = 'none';
    }
}
	</script>
</body>

</html>