<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]>      <html class="no-js"> <!--<![endif]-->
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>owi5</title>
    <meta name="description" content="">
    <meta name="nova-include" content="material-symbols-rounded">
    <meta name="permissions" content="unsandboxed, olp">
    <meta name="nova-icon" content="<svg width='318' height='318' viewBox='0 0 318 318' fill='none' xmlns='http://www.w3.org/2000/svg'> <g clip-path='url(#clip0_1_3)'> <rect x='-1' y='-1' width='319' height='319' rx='30' fill='#A260FF'/> <path d='M274.691 245.703C274.691 253.32 273.314 259.941 270.561 265.566C267.865 271.191 264.174 275.85 259.486 279.541C254.799 283.232 249.291 285.986 242.963 287.803C236.635 289.619 229.867 290.527 222.66 290.527C219.203 290.527 215.805 290.293 212.465 289.824C209.125 289.297 205.814 288.623 202.533 287.803C199.311 286.924 196.088 285.928 192.865 284.814C189.701 283.701 186.508 282.5 183.285 281.211L186.625 246.23C188.734 247.402 190.99 248.486 193.393 249.482C195.795 250.479 198.256 251.328 200.775 252.031C203.354 252.734 205.932 253.291 208.51 253.701C211.146 254.111 213.695 254.316 216.156 254.316C217.621 254.316 219.408 254.199 221.518 253.965C223.627 253.672 225.648 253.174 227.582 252.471C229.516 251.709 231.156 250.713 232.504 249.482C233.91 248.193 234.613 246.523 234.613 244.473C234.613 242.539 234.057 240.869 232.943 239.463C231.889 238.057 230.482 236.914 228.725 236.035C227.025 235.098 225.092 234.365 222.924 233.838C220.756 233.311 218.559 232.9 216.332 232.607C214.164 232.314 212.084 232.139 210.092 232.08C208.158 232.021 206.547 231.992 205.258 231.992C202.621 231.992 199.926 232.109 197.172 232.344C194.477 232.578 191.84 233.047 189.262 233.75L192.777 162.734L263.969 160.801L265.902 197.539L221.781 195.078L220.902 210.723C223.539 210.078 226.176 209.609 228.812 209.316C231.449 208.965 234.086 208.789 236.723 208.789C242.055 208.789 247.006 209.668 251.576 211.426C256.205 213.125 260.219 215.586 263.617 218.809C267.074 222.031 269.77 225.928 271.703 230.498C273.695 235.01 274.691 240.078 274.691 245.703Z' fill='white'/> <line x1='45.3548' y1='172.554' x2='88.3548' y2='121.554' stroke='white' stroke-width='20'/> <line x1='75.1248' y1='120.983' x2='140.125' y2='186.983' stroke='white' stroke-width='20'/> <line x1='109.749' y1='162.35' x2='185.749' y2='51.3505' stroke='white' stroke-width='20'/> <line x1='174.125' y1='49.9831' x2='239.125' y2='115.983' stroke='white' stroke-width='20'/> </g> <defs> <clipPath id='clip0_1_3'> <rect width='318' height='318' fill='white'/> </clipPath> </defs> </svg>">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap');

        html {
            height: 100%;
            width: 100%;
        }

        body {
            height: 100%;
            width: 100%;
            margin: 0;
            background-color: #111113;
            color: white;
            display: flex;
            flex-direction: column;
            font-size: 14px;
            font-family: "IBM Plex Sans", sans-serif;
        }

        :root {
            --dull-bg: #111113;
            --main-bg: #18191b;
            --high-bg: #33363b;
            --box-crisp: 1px solid #393b41;
        }

        button,
        input,
        textarea {
            background-color: transparent;
            color: inherit;
            padding: 0;
            border: 0;
            outline: 0;
            font-family: inherit;
            font-size: inherit;
        }

        @keyframes showUp {
            0% {
                transform: translateY(3px);
                opacity: 0;
            }

            100% {
                transform: translateY(0px);
                opacity: 1;
            }
        }

        .main_nav {
            display: flex;
            flex-direction: row;
            gap: 5px;
            padding: 5px;
            background-color: #18191b;


            &>.dropdown {
                position: relative;

                &:hover>button {
                    background-color: #28292a;
                }

                &>button {
                    padding: 5px 8px;
                    border-radius: 5px;

                    &:hover {
                        background-color: #28292a;
                    }
                }
            }

            & .dropdown-content {
                position: absolute;
                animation: showUp .2s;
                box-shadow: 0 5px 10px #0000003a;
                top: 100%;
                left: 0;
                display: none;
                flex-direction: column;
                background: var(--main-bg);
                border: var(--box-crisp);
                border-radius: 5px;
                min-width: 100px;
                z-index: 1;
                overflow: hidden;

                &>a {
                    all: unset;
                    padding: 5px 8px;
                    border-radius: 0px;

                    &:hover {
                        background-color: #28292a;
                    }
                }
            }

            & .dropdown:hover .dropdown-content {
                display: flex;
            }

        }

        .panels {
            display: flex;
            flex-direction: row;
            flex: 1;
            border-top: var(--box-crisp);
            height: 0;

            &>.panel {
                background-color: #18191b;
                padding: 10px;
                border-left: var(--box-crisp);
                border-right: var(--box-crisp);
                flex: 1;
            }
        }

        .effects_grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(65px, 70px));
            gap: 5px;
        }

        .singular_effect_btn {
            padding: 10px;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: fit-content;
            aspect-ratio: 1 / 1;

            &:hover {
                background-color: #28292a;
            }

            &.active {
                background-color: #33363b;
            }
        }

        .seperator {
            display: block;
            background-color: #393b41;
            height: 1px;
            margin: 1em 0px;
        }

        #effect_tools {
            display: flex;
            flex-direction: column;
            align-items: stretch;

            &>.label {
                opacity: .5;
                font-size: 12px;
                text-transform: uppercase;
            }
        }

        .realLabel {
            opacity: .5;
            font-size: 12px;
            text-transform: uppercase;
        }

        .range-wrapper {
            position: relative;
            height: 6px;
            background: #393b41;
            border-radius: 3px;
            margin: 10px 0;
            cursor: pointer;
        }

        .range-fill {
            height: 100%;
            background: #52565d;
            border-radius: 3px 0 0 3px;
        }

        .range-thumb {
            position: absolute;
            top: -5px;
            width: 16px;
            height: 16px;
            background: #52565d;
            border-radius: 50%;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
            transition: background 0.2s;
        }

        .output_panel {
            flex: 3;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;

            #canvas {
                max-width: 100%;
                max-height: 100%;
                box-shadow: 0 3px 10px rgba(0, 0, 0, 0.489);
            }
        }

        #effectlist {
            margin-top: 5px;
        }

        .effectinlist {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            border-radius: 5px;
            cursor: grab;

            &:hover {
                background-color: #36393f;
            }

            &:active {
                cursor: grabbing;
            }

            &>.handle {
                font-size: 15px;
            }
        }


        .effectinlist.dragging {
            opacity: 0.5;
        }

        .effectinlist.over {
            border: 2px dashed #007bff;
        }

        .dialog_window {
            display: none;
            position: absolute;
            align-items: flex-start;
            justify-content: center;
            width: 100%;
            height: 100%;
            background: #00000033;

            & .content {
                background-color: var(--main-bg);
                margin-top: 1em;
                padding: 1em;
                border-radius: 5px;
                border: var(--box-crisp);
                max-height: 300px;
                overflow-y: auto;
                box-shadow: 0 3px 10px #000000a6;

                &>.header {
                    display: flex;
                    flex-direction: row;
                    flex-wrap: nowrap;
                    justify-content: space-between;
                    align-items: center;
                    padding-bottom: .5em;

                    & .clbtn {
                        font-size: 15px;
                        padding: 3px;
                        display: flex;
                        border-radius: 5px;
                        cursor: pointer;
                        background-color: var(--high-bg);
                    }
                }
            }

            .setting {
                display: flex;
                padding-top: .5em;
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                flex-wrap: nowrap;
                gap: 1em;
                max-width: 350px;
                border-top: 1px solid var(--high-bg);

                &>.text_part {
                    flex: 1;

                    &>p {
                        margin: 0;
                        opacity: .5;
                        font-size: small;
                        margin-top: 5px;
                    }
                }

                &>input {
                    min-width: 0;
                    width: 32px;
                    background: var(--dull-bg);
                    padding: .5em;
                    border-radius: 5px;
                    text-align: center;
                }
            }
        }
    </style>

    <script>
        function rangeInit(selector = 'input[type=range]') {
            document.querySelectorAll(selector).forEach(original => {
                const min = +original.min || 0;
                const max = +original.max || 100;
                const step = +original.step || 1;
                const center = min + ((max - min) / 2);
                let val = original.value === '' ? center : +original.value;

                const wrapper = document.createElement('div');
                wrapper.classList.add('range-wrapper');

                const fill = document.createElement('div');
                fill.classList.add('range-fill');
                wrapper.appendChild(fill);

                const thumb = document.createElement('span');
                thumb.classList.add('range-thumb');
                wrapper.appendChild(thumb);

                function update(v) {
                    const p = percent(v, min, max);
                    fill.style.width = p + '%';
                    thumb.style.left = `calc(${p}% - 6px)`;
                }

                update(val);

                wrapper.addEventListener('mousedown', startDrag);
                wrapper.addEventListener('touchstart', startDrag, { passive: false });

                function startDrag(e) {
                    e.preventDefault();
                    const move = (ev) => {
                        const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
                        const rect = wrapper.getBoundingClientRect();
                        let ratio = (clientX - rect.left) / rect.width;
                        ratio = Math.max(0, Math.min(1, ratio));
                        let rawVal = min + (max - min) * ratio;

                        const snapThreshold = (max - min) * 0.02;
                        let newVal = rawVal;

                        if (!original.hasAttribute('data-nosnap') && Math.abs(rawVal - center) < snapThreshold) {
                            newVal = center;
                        }

                        newVal = Math.round((newVal - min) / step) * step + min;
                        newVal = Math.max(min, Math.min(max, newVal));

                        original.value = newVal;
                        update(newVal);
                        original.dispatchEvent(new Event('input'));
                    };

                    const stop = () => {
                        document.removeEventListener('mousemove', move);
                        document.removeEventListener('mouseup', stop);
                        document.removeEventListener('touchmove', move);
                        document.removeEventListener('touchend', stop);
                    };

                    document.addEventListener('mousemove', move);
                    document.addEventListener('mouseup', stop);
                    document.addEventListener('touchmove', move);
                    document.addEventListener('touchend', stop);
                }

                const observer = new MutationObserver(() => {
                    update(Number.isFinite(+original.value) ? +original.value : center);
                });

                original.addEventListener('input', () => {
                    update(Number.isFinite(+original.value) ? +original.value : center);
                });


                observer.observe(original, { attributes: true, attributeFilter: ['value'] });

                original.style.display = 'none';
                original.parentNode.insertBefore(wrapper, original.nextSibling);

                if (original.value === '') {
                    original.value = center;
                    original.dispatchEvent(new Event('input'));
                }
            });
        }

        function percent(val, min, max) {
            return ((val - min) / (max - min)) * 100;
        }

        var eff = (function () {
            var state = {
                appliedEffects: [],
                originalImage: null,
                ctx: null,
                canvas: null
            };

            function initializeCanvas() {
                var img = document.getElementById('source');
                state.canvas = document.getElementById('canvas');
                state.ctx = state.canvas.getContext('2d');
                state.canvas.width = img.naturalWidth;
                state.canvas.height = img.naturalHeight;
                state.originalImage = img;
                state.appliedEffects = [];
                state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
                state.ctx.drawImage(img, 0, 0, state.canvas.width, state.canvas.height);
            }

            function applyToCanvas(modifier) {
                var imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
                var data = imageData.data;
                for (var i = 0; i < data.length; i += 4) {
                    var hsl = rgbToHsl(data[i], data[i + 1], data[i + 2]);
                    hsl = modifier(hsl);
                    var rgb = hslToRgb(hsl[0], hsl[1], hsl[2]);
                    data[i] = rgb[0];
                    data[i + 1] = rgb[1];
                    data[i + 2] = rgb[2];
                }
                state.ctx.putImageData(imageData, 0, 0);
            }

            function rgbToHsl(r, g, b) {
                r /= 255; g /= 255; b /= 255;
                var max = Math.max(r, g, b), min = Math.min(r, g, b);
                var h, s, l = (max + min) / 2;
                if (max === min) { h = s = 0; }
                else {
                    var d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = ((g - b) / d + (g < b ? 6 : 0)); break;
                        case g: h = ((b - r) / d + 2); break;
                        case b: h = ((r - g) / d + 4); break;
                    }
                    h /= 6;
                }
                return [h, s, l];
            }

            function hslToRgb(h, s, l) {
                var r, g, b;
                if (s === 0) { r = g = b = l; }
                else {
                    function hue2rgb(p, q, t) {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    }
                    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    var p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1 / 3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1 / 3);
                }
                return [r * 255, g * 255, b * 255];
            }

            function applyConvolution(srcData, width, height, weights, done) {
                var output = state.ctx.createImageData(width, height);
                var dst = output.data;
                var side = Math.sqrt(weights.length);
                var halfSide = Math.floor(side / 2);
                for (var y = 0; y < height; y++) {
                    for (var x = 0; x < width; x++) {
                        var r = 0, g = 0, b = 0;
                        for (var cy = 0; cy < side; cy++) {
                            for (var cx = 0; cx < side; cx++) {
                                var scy = y + cy - halfSide;
                                var scx = x + cx - halfSide;
                                if (scy >= 0 && scy < height && scx >= 0 && scx < width) {
                                    var offset = (scy * width + scx) * 4;
                                    var wt = weights[cy * side + cx];
                                    r += srcData[offset] * wt;
                                    g += srcData[offset + 1] * wt;
                                    b += srcData[offset + 2] * wt;
                                }
                            }
                        }
                        var dstOffset = (y * width + x) * 4;
                        dst[dstOffset] = r;
                        dst[dstOffset + 1] = g;
                        dst[dstOffset + 2] = b;
                        dst[dstOffset + 3] = 255;
                    }
                }
                done(output);
            }

            var effectslib = {
                colors: {
                    icon: "colors",
                    hue: Object.assign(function (degree) {
                        applyToCanvas(function (hsl) {
                            var h = (hsl[0] * 360 + degree) % 360;
                            if (h < 0) h += 360;
                            h /= 360;
                            return [h, hsl[1], hsl[2]];
                        });
                    }, { _meta: { type: "range", min: -180, max: 180, step: 1, default: 0, label: "Hue" } }),
                    saturation: Object.assign(function (amount) {
                        applyToCanvas(function (hsl) {
                            return [hsl[0], Math.min(1, Math.max(0, hsl[1] + amount / 100)), hsl[2]];
                        });
                    }, { _meta: { type: "range", min: -100, max: 100, step: 1, default: 0, label: "Saturation" } }),
                    contrast: Object.assign(function (amount) {
                        var factor = (259 * (amount + 255)) / (255 * (259 - amount));
                        var imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
                        var data = imageData.data;
                        for (var i = 0; i < data.length; i += 4) {
                            data[i] = factor * (data[i] - 128) + 128;
                            data[i + 1] = factor * (data[i + 1] - 128) + 128;
                            data[i + 2] = factor * (data[i + 2] - 128) + 128;
                        }
                        state.ctx.putImageData(imageData, 0, 0);
                    }, { _meta: { type: "range", min: -255, max: 255, step: 1, default: 0, label: "Contrast" } }),
                    brightness: Object.assign(function (amount) {
                        var imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
                        var data = imageData.data;
                        for (var i = 0; i < data.length; i += 4) {
                            data[i] += amount;
                            data[i + 1] += amount;
                            data[i + 2] += amount;
                        }
                        state.ctx.putImageData(imageData, 0, 0);
                    }, { _meta: { type: "range", min: -255, max: 255, step: 1, default: 0, label: "Brightness" } })
                },
                filters: {
                    icon: "blur_on",
                    blur: Object.assign(function (amount) {
                        if (amount <= 0) return 1;
                        var imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
                        var src = imageData.data;
                        var sw = imageData.width;
                        var sh = imageData.height;
                        var temp = new Uint8ClampedArray(src);
                        var side = 3, halfSide = Math.floor(side / 2);
                        var weights = [1 / 3, 1 / 3, 1 / 3];
                        function blur1D(src, dst, w, h, horizontal) {
                            for (var y = 0; y < h; y++) {
                                for (var x = 0; x < w; x++) {
                                    var r = 0, g = 0, b = 0, a = 0;
                                    for (var k = -halfSide; k <= halfSide; k++) {
                                        var ix = horizontal ? x + k : x;
                                        var iy = horizontal ? y : y + k;
                                        if (ix >= 0 && ix < w && iy >= 0 && iy < h) {
                                            var offset = (iy * w + ix) * 4;
                                            var wt = weights[k + halfSide];
                                            r += src[offset] * wt;
                                            g += src[offset + 1] * wt;
                                            b += src[offset + 2] * wt;
                                            a += src[offset + 3] * wt;
                                        }
                                    }
                                    var dstOffset = (y * w + x) * 4;
                                    dst[dstOffset] = r;
                                    dst[dstOffset + 1] = g;
                                    dst[dstOffset + 2] = b;
                                    dst[dstOffset + 3] = a;
                                }
                            }
                        }
                        for (var i = 0; i < amount; i++) {
                            blur1D(src, temp, sw, sh, true);
                            blur1D(temp, src, sw, sh, false);
                        }
                        state.ctx.putImageData(new ImageData(src, sw, sh), 0, 0);
                    }, { _meta: { type: "range", min: 0, max: 20, step: 5, default: 0, label: "Blur", nosnap: true } }),
                    sharpen: Object.assign(function (amount) {
                        var imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
                        var data = imageData.data;
                        var width = imageData.width;
                        var height = imageData.height;
                        var kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
                        var sharpenFactor = amount / 100;
                        var finalKernel = kernel.map(function (v, i) {
                            var identity = (i === 4) ? 1 : 0;
                            return identity + (v - identity) * sharpenFactor;
                        });
                        applyConvolution(data, width, height, finalKernel, function (output) {
                            state.ctx.putImageData(output, 0, 0);
                        });
                    }, { _meta: { type: "range", min: 0, max: 100, step: 1, default: 0, label: "Sharpen" } }),
                    denoise: Object.assign(function (amount) {
                        if (amount <= 0) return;
                        var imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
                        var data = imageData.data;
                        var width = imageData.width;
                        var height = imageData.height;
                        var strength = amount / 100;
                        var baseWeight = 1 - strength;
                        var blurWeight = strength / 8;
                        var kernel = [
                            blurWeight, blurWeight, blurWeight,
                            blurWeight, baseWeight, blurWeight,
                            blurWeight, blurWeight, blurWeight
                        ];
                        applyConvolution(data, width, height, kernel, function (output) {
                            state.ctx.putImageData(output, 0, 0);
                        });
                    }, { _meta: { type: "range", min: 0, max: 100, step: 1, default: 0, label: "Denoise" } })
                }
            };

            return {
                state: state,
                initializeCanvas: initializeCanvas,
                applyToCanvas: applyToCanvas,
                rgbToHsl: rgbToHsl,
                hslToRgb: hslToRgb,
                effectslib: effectslib
            };
        })();

    </script>


    <script>
        /*! Sortable 1.15.0 - MIT | git://github.com/SortableJS/Sortable.git */
        !function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = t || self).Sortable = e() }(this, function () { "use strict"; function e(e, t) { var n, o = Object.keys(e); return Object.getOwnPropertySymbols && (n = Object.getOwnPropertySymbols(e), t && (n = n.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), o.push.apply(o, n)), o } function M(o) { for (var t = 1; t < arguments.length; t++) { var i = null != arguments[t] ? arguments[t] : {}; t % 2 ? e(Object(i), !0).forEach(function (t) { var e, n; e = o, t = i[n = t], n in e ? Object.defineProperty(e, n, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[n] = t }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : e(Object(i)).forEach(function (t) { Object.defineProperty(o, t, Object.getOwnPropertyDescriptor(i, t)) }) } return o } function o(t) { return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function a() { return (a = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n, o = arguments[e]; for (n in o) Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]) } return t }).apply(this, arguments) } function i(t, e) { if (null == t) return {}; var n, o = function (t, e) { if (null == t) return {}; for (var n, o = {}, i = Object.keys(t), r = 0; r < i.length; r++)n = i[r], 0 <= e.indexOf(n) || (o[n] = t[n]); return o }(t, e); if (Object.getOwnPropertySymbols) for (var i = Object.getOwnPropertySymbols(t), r = 0; r < i.length; r++)n = i[r], 0 <= e.indexOf(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (o[n] = t[n]); return o } function r(t) { return function (t) { if (Array.isArray(t)) return l(t) }(t) || function (t) { if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t) }(t) || function (t, e) { if (t) { if ("string" == typeof t) return l(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); return "Map" === (n = "Object" === n && t.constructor ? t.constructor.name : n) || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? l(t, e) : void 0 } }(t) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function l(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, o = new Array(e); n < e; n++)o[n] = t[n]; return o } function t(t) { if ("undefined" != typeof window && window.navigator) return !!navigator.userAgent.match(t) } var y = t(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), w = t(/Edge/i), s = t(/firefox/i), u = t(/safari/i) && !t(/chrome/i) && !t(/android/i), n = t(/iP(ad|od|hone)/i), c = t(/chrome/i) && t(/android/i), d = { capture: !1, passive: !1 }; function h(t, e, n) { t.addEventListener(e, n, !y && d) } function f(t, e, n) { t.removeEventListener(e, n, !y && d) } function p(t, e) { if (e && (">" === e[0] && (e = e.substring(1)), t)) try { if (t.matches) return t.matches(e); if (t.msMatchesSelector) return t.msMatchesSelector(e); if (t.webkitMatchesSelector) return t.webkitMatchesSelector(e) } catch (t) { return } } function N(t, e, n, o) { if (t) { n = n || document; do { if (null != e && (">" !== e[0] || t.parentNode === n) && p(t, e) || o && t === n) return t } while (t !== n && (t = (i = t).host && i !== document && i.host.nodeType ? i.host : i.parentNode)) } var i; return null } var g, m = /\s+/g; function I(t, e, n) { var o; t && e && (t.classList ? t.classList[n ? "add" : "remove"](e) : (o = (" " + t.className + " ").replace(m, " ").replace(" " + e + " ", " "), t.className = (o + (n ? " " + e : "")).replace(m, " "))) } function P(t, e, n) { var o = t && t.style; if (o) { if (void 0 === n) return document.defaultView && document.defaultView.getComputedStyle ? n = document.defaultView.getComputedStyle(t, "") : t.currentStyle && (n = t.currentStyle), void 0 === e ? n : n[e]; o[e = !(e in o || -1 !== e.indexOf("webkit")) ? "-webkit-" + e : e] = n + ("string" == typeof n ? "" : "px") } } function v(t, e) { var n = ""; if ("string" == typeof t) n = t; else do { var o = P(t, "transform") } while (o && "none" !== o && (n = o + " " + n), !e && (t = t.parentNode)); var i = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix; return i && new i(n) } function b(t, e, n) { if (t) { var o = t.getElementsByTagName(e), i = 0, r = o.length; if (n) for (; i < r; i++)n(o[i], i); return o } return [] } function O() { var t = document.scrollingElement; return t || document.documentElement } function k(t, e, n, o, i) { if (t.getBoundingClientRect || t === window) { var r, a, l, s, c, u, d = t !== window && t.parentNode && t !== O() ? (a = (r = t.getBoundingClientRect()).top, l = r.left, s = r.bottom, c = r.right, u = r.height, r.width) : (l = a = 0, s = window.innerHeight, c = window.innerWidth, u = window.innerHeight, window.innerWidth); if ((e || n) && t !== window && (i = i || t.parentNode, !y)) do { if (i && i.getBoundingClientRect && ("none" !== P(i, "transform") || n && "static" !== P(i, "position"))) { var h = i.getBoundingClientRect(); a -= h.top + parseInt(P(i, "border-top-width")), l -= h.left + parseInt(P(i, "border-left-width")), s = a + r.height, c = l + r.width; break } } while (i = i.parentNode); return o && t !== window && (o = (e = v(i || t)) && e.a, t = e && e.d, e && (s = (a /= t) + (u /= t), c = (l /= o) + (d /= o))), { top: a, left: l, bottom: s, right: c, width: d, height: u } } } function R(t, e, n) { for (var o = A(t, !0), i = k(t)[e]; o;) { var r = k(o)[n]; if (!("top" === n || "left" === n ? r <= i : i <= r)) return o; if (o === O()) break; o = A(o, !1) } return !1 } function X(t, e, n, o) { for (var i = 0, r = 0, a = t.children; r < a.length;) { if ("none" !== a[r].style.display && a[r] !== Bt.ghost && (o || a[r] !== Bt.dragged) && N(a[r], n.draggable, t, !1)) { if (i === e) return a[r]; i++ } r++ } return null } function Y(t, e) { for (var n = t.lastElementChild; n && (n === Bt.ghost || "none" === P(n, "display") || e && !p(n, e));)n = n.previousElementSibling; return n || null } function B(t, e) { var n = 0; if (!t || !t.parentNode) return -1; for (; t = t.previousElementSibling;)"TEMPLATE" === t.nodeName.toUpperCase() || t === Bt.clone || e && !p(t, e) || n++; return n } function E(t) { var e = 0, n = 0, o = O(); if (t) do { var i = v(t), r = i.a, i = i.d } while (e += t.scrollLeft * r, n += t.scrollTop * i, t !== o && (t = t.parentNode)); return [e, n] } function A(t, e) { if (!t || !t.getBoundingClientRect) return O(); var n = t, o = !1; do { if (n.clientWidth < n.scrollWidth || n.clientHeight < n.scrollHeight) { var i = P(n); if (n.clientWidth < n.scrollWidth && ("auto" == i.overflowX || "scroll" == i.overflowX) || n.clientHeight < n.scrollHeight && ("auto" == i.overflowY || "scroll" == i.overflowY)) { if (!n.getBoundingClientRect || n === document.body) return O(); if (o || e) return n; o = !0 } } } while (n = n.parentNode); return O() } function D(t, e) { return Math.round(t.top) === Math.round(e.top) && Math.round(t.left) === Math.round(e.left) && Math.round(t.height) === Math.round(e.height) && Math.round(t.width) === Math.round(e.width) } function S(e, n) { return function () { var t; g || (1 === (t = arguments).length ? e.call(this, t[0]) : e.apply(this, t), g = setTimeout(function () { g = void 0 }, n)) } } function F(t, e, n) { t.scrollLeft += e, t.scrollTop += n } function _(t) { var e = window.Polymer, n = window.jQuery || window.Zepto; return e && e.dom ? e.dom(t).cloneNode(!0) : n ? n(t).clone(!0)[0] : t.cloneNode(!0) } function C(t, e) { P(t, "position", "absolute"), P(t, "top", e.top), P(t, "left", e.left), P(t, "width", e.width), P(t, "height", e.height) } function T(t) { P(t, "position", ""), P(t, "top", ""), P(t, "left", ""), P(t, "width", ""), P(t, "height", "") } var j = "Sortable" + (new Date).getTime(); function x() { var e, o = []; return { captureAnimationState: function () { o = [], this.options.animation && [].slice.call(this.el.children).forEach(function (t) { var e, n; "none" !== P(t, "display") && t !== Bt.ghost && (o.push({ target: t, rect: k(t) }), e = M({}, o[o.length - 1].rect), !t.thisAnimationDuration || (n = v(t, !0)) && (e.top -= n.f, e.left -= n.e), t.fromRect = e) }) }, addAnimationState: function (t) { o.push(t) }, removeAnimationState: function (t) { o.splice(function (t, e) { for (var n in t) if (t.hasOwnProperty(n)) for (var o in e) if (e.hasOwnProperty(o) && e[o] === t[n][o]) return Number(n); return -1 }(o, { target: t }), 1) }, animateAll: function (t) { var c = this; if (!this.options.animation) return clearTimeout(e), void ("function" == typeof t && t()); var u = !1, d = 0; o.forEach(function (t) { var e = 0, n = t.target, o = n.fromRect, i = k(n), r = n.prevFromRect, a = n.prevToRect, l = t.rect, s = v(n, !0); s && (i.top -= s.f, i.left -= s.e), n.toRect = i, n.thisAnimationDuration && D(r, i) && !D(o, i) && (l.top - i.top) / (l.left - i.left) == (o.top - i.top) / (o.left - i.left) && (t = l, s = r, r = a, a = c.options, e = Math.sqrt(Math.pow(s.top - t.top, 2) + Math.pow(s.left - t.left, 2)) / Math.sqrt(Math.pow(s.top - r.top, 2) + Math.pow(s.left - r.left, 2)) * a.animation), D(i, o) || (n.prevFromRect = o, n.prevToRect = i, e = e || c.options.animation, c.animate(n, l, i, e)), e && (u = !0, d = Math.max(d, e), clearTimeout(n.animationResetTimer), n.animationResetTimer = setTimeout(function () { n.animationTime = 0, n.prevFromRect = null, n.fromRect = null, n.prevToRect = null, n.thisAnimationDuration = null }, e), n.thisAnimationDuration = e) }), clearTimeout(e), u ? e = setTimeout(function () { "function" == typeof t && t() }, d) : "function" == typeof t && t(), o = [] }, animate: function (t, e, n, o) { var i, r; o && (P(t, "transition", ""), P(t, "transform", ""), i = (r = v(this.el)) && r.a, r = r && r.d, i = (e.left - n.left) / (i || 1), r = (e.top - n.top) / (r || 1), t.animatingX = !!i, t.animatingY = !!r, P(t, "transform", "translate3d(" + i + "px," + r + "px,0)"), this.forRepaintDummy = t.offsetWidth, P(t, "transition", "transform " + o + "ms" + (this.options.easing ? " " + this.options.easing : "")), P(t, "transform", "translate3d(0,0,0)"), "number" == typeof t.animated && clearTimeout(t.animated), t.animated = setTimeout(function () { P(t, "transition", ""), P(t, "transform", ""), t.animated = !1, t.animatingX = !1, t.animatingY = !1 }, o)) } } } var H = [], L = { initializeByDefault: !0 }, K = { mount: function (e) { for (var t in L) !L.hasOwnProperty(t) || t in e || (e[t] = L[t]); H.forEach(function (t) { if (t.pluginName === e.pluginName) throw "Sortable: Cannot mount plugin ".concat(e.pluginName, " more than once") }), H.push(e) }, pluginEvent: function (e, n, o) { var t = this; this.eventCanceled = !1, o.cancel = function () { t.eventCanceled = !0 }; var i = e + "Global"; H.forEach(function (t) { n[t.pluginName] && (n[t.pluginName][i] && n[t.pluginName][i](M({ sortable: n }, o)), n.options[t.pluginName] && n[t.pluginName][e] && n[t.pluginName][e](M({ sortable: n }, o))) }) }, initializePlugins: function (n, o, i, t) { for (var e in H.forEach(function (t) { var e = t.pluginName; (n.options[e] || t.initializeByDefault) && ((t = new t(n, o, n.options)).sortable = n, t.options = n.options, n[e] = t, a(i, t.defaults)) }), n.options) { var r; n.options.hasOwnProperty(e) && (void 0 !== (r = this.modifyOption(n, e, n.options[e])) && (n.options[e] = r)) } }, getEventProperties: function (e, n) { var o = {}; return H.forEach(function (t) { "function" == typeof t.eventProperties && a(o, t.eventProperties.call(n[t.pluginName], e)) }), o }, modifyOption: function (e, n, o) { var i; return H.forEach(function (t) { e[t.pluginName] && t.optionListeners && "function" == typeof t.optionListeners[n] && (i = t.optionListeners[n].call(e[t.pluginName], o)) }), i } }; function W(t) { var e = t.sortable, n = t.rootEl, o = t.name, i = t.targetEl, r = t.cloneEl, a = t.toEl, l = t.fromEl, s = t.oldIndex, c = t.newIndex, u = t.oldDraggableIndex, d = t.newDraggableIndex, h = t.originalEvent, f = t.putSortable, p = t.extraEventProperties; if (e = e || n && n[j]) { var g, m = e.options, t = "on" + o.charAt(0).toUpperCase() + o.substr(1); !window.CustomEvent || y || w ? (g = document.createEvent("Event")).initEvent(o, !0, !0) : g = new CustomEvent(o, { bubbles: !0, cancelable: !0 }), g.to = a || n, g.from = l || n, g.item = i || n, g.clone = r, g.oldIndex = s, g.newIndex = c, g.oldDraggableIndex = u, g.newDraggableIndex = d, g.originalEvent = h, g.pullMode = f ? f.lastPutMode : void 0; var v, b = M(M({}, p), K.getEventProperties(o, e)); for (v in b) g[v] = b[v]; n && n.dispatchEvent(g), m[t] && m[t].call(e, g) } } function z(t, e) { var n = (o = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {}).evt, o = i(o, G); K.pluginEvent.bind(Bt)(t, e, M({ dragEl: q, parentEl: V, ghostEl: Z, rootEl: $, nextEl: Q, lastDownEl: J, cloneEl: tt, cloneHidden: et, dragStarted: pt, putSortable: lt, activeSortable: Bt.active, originalEvent: n, oldIndex: nt, oldDraggableIndex: it, newIndex: ot, newDraggableIndex: rt, hideGhostForTarget: kt, unhideGhostForTarget: Rt, cloneNowHidden: function () { et = !0 }, cloneNowShown: function () { et = !1 }, dispatchSortableEvent: function (t) { U({ sortable: e, name: t, originalEvent: n }) } }, o)) } var G = ["evt"]; function U(t) { W(M({ putSortable: lt, cloneEl: tt, targetEl: q, rootEl: $, oldIndex: nt, oldDraggableIndex: it, newIndex: ot, newDraggableIndex: rt }, t)) } var q, V, Z, $, Q, J, tt, et, nt, ot, it, rt, at, lt, st, ct, ut, dt, ht, ft, pt, gt, mt, vt, bt, yt = !1, wt = !1, Et = [], Dt = !1, St = !1, _t = [], Ct = !1, Tt = [], xt = "undefined" != typeof document, Ot = n, At = w || y ? "cssFloat" : "float", Mt = xt && !c && !n && "draggable" in document.createElement("div"), Nt = function () { if (xt) { if (y) return !1; var t = document.createElement("x"); return t.style.cssText = "pointer-events:auto", "auto" === t.style.pointerEvents } }(), It = function (t, e) { var n = P(t), o = parseInt(n.width) - parseInt(n.paddingLeft) - parseInt(n.paddingRight) - parseInt(n.borderLeftWidth) - parseInt(n.borderRightWidth), i = X(t, 0, e), r = X(t, 1, e), a = i && P(i), l = r && P(r), s = a && parseInt(a.marginLeft) + parseInt(a.marginRight) + k(i).width, t = l && parseInt(l.marginLeft) + parseInt(l.marginRight) + k(r).width; if ("flex" === n.display) return "column" === n.flexDirection || "column-reverse" === n.flexDirection ? "vertical" : "horizontal"; if ("grid" === n.display) return n.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal"; if (i && a.float && "none" !== a.float) { e = "left" === a.float ? "left" : "right"; return !r || "both" !== l.clear && l.clear !== e ? "horizontal" : "vertical" } return i && ("block" === a.display || "flex" === a.display || "table" === a.display || "grid" === a.display || o <= s && "none" === n[At] || r && "none" === n[At] && o < s + t) ? "vertical" : "horizontal" }, Pt = function (t) { function l(r, a) { return function (t, e, n, o) { var i = t.options.group.name && e.options.group.name && t.options.group.name === e.options.group.name; if (null == r && (a || i)) return !0; if (null == r || !1 === r) return !1; if (a && "clone" === r) return r; if ("function" == typeof r) return l(r(t, e, n, o), a)(t, e, n, o); e = (a ? t : e).options.group.name; return !0 === r || "string" == typeof r && r === e || r.join && -1 < r.indexOf(e) } } var e = {}, n = t.group; n && "object" == o(n) || (n = { name: n }), e.name = n.name, e.checkPull = l(n.pull, !0), e.checkPut = l(n.put), e.revertClone = n.revertClone, t.group = e }, kt = function () { !Nt && Z && P(Z, "display", "none") }, Rt = function () { !Nt && Z && P(Z, "display", "") }; xt && !c && document.addEventListener("click", function (t) { if (wt) return t.preventDefault(), t.stopPropagation && t.stopPropagation(), t.stopImmediatePropagation && t.stopImmediatePropagation(), wt = !1 }, !0); function Xt(t) { if (q) { t = t.touches ? t.touches[0] : t; var e = (i = t.clientX, r = t.clientY, Et.some(function (t) { var e = t[j].options.emptyInsertThreshold; if (e && !Y(t)) { var n = k(t), o = i >= n.left - e && i <= n.right + e, e = r >= n.top - e && r <= n.bottom + e; return o && e ? a = t : void 0 } }), a); if (e) { var n, o = {}; for (n in t) t.hasOwnProperty(n) && (o[n] = t[n]); o.target = o.rootEl = e, o.preventDefault = void 0, o.stopPropagation = void 0, e[j]._onDragOver(o) } } var i, r, a } function Yt(t) { q && q.parentNode[j]._isOutsideThisEl(t.target) } function Bt(t, e) { if (!t || !t.nodeType || 1 !== t.nodeType) throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(t)); this.el = t, this.options = e = a({}, e), t[j] = this; var n, o, i = { group: null, sort: !0, disabled: !1, store: null, handle: null, draggable: /^[uo]l$/i.test(t.nodeName) ? ">li" : ">*", swapThreshold: 1, invertSwap: !1, invertedSwapThreshold: null, removeCloneOnHide: !0, direction: function () { return It(t, this.options) }, ghostClass: "sortable-ghost", chosenClass: "sortable-chosen", dragClass: "sortable-drag", ignore: "a, img", filter: null, preventOnFilter: !0, animation: 0, easing: null, setData: function (t, e) { t.setData("Text", e.textContent) }, dropBubble: !1, dragoverBubble: !1, dataIdAttr: "data-id", delay: 0, delayOnTouchOnly: !1, touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1, forceFallback: !1, fallbackClass: "sortable-fallback", fallbackOnBody: !1, fallbackTolerance: 0, fallbackOffset: { x: 0, y: 0 }, supportPointer: !1 !== Bt.supportPointer && "PointerEvent" in window && !u, emptyInsertThreshold: 5 }; for (n in K.initializePlugins(this, t, i), i) n in e || (e[n] = i[n]); for (o in Pt(e), this) "_" === o.charAt(0) && "function" == typeof this[o] && (this[o] = this[o].bind(this)); this.nativeDraggable = !e.forceFallback && Mt, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? h(t, "pointerdown", this._onTapStart) : (h(t, "mousedown", this._onTapStart), h(t, "touchstart", this._onTapStart)), this.nativeDraggable && (h(t, "dragover", this), h(t, "dragenter", this)), Et.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []), a(this, x()) } function Ft(t, e, n, o, i, r, a, l) { var s, c, u = t[j], d = u.options.onMove; return !window.CustomEvent || y || w ? (s = document.createEvent("Event")).initEvent("move", !0, !0) : s = new CustomEvent("move", { bubbles: !0, cancelable: !0 }), s.to = e, s.from = t, s.dragged = n, s.draggedRect = o, s.related = i || e, s.relatedRect = r || k(e), s.willInsertAfter = l, s.originalEvent = a, t.dispatchEvent(s), c = d ? d.call(u, s, a) : c } function jt(t) { t.draggable = !1 } function Ht() { Ct = !1 } function Lt(t) { return setTimeout(t, 0) } function Kt(t) { return clearTimeout(t) } Bt.prototype = { constructor: Bt, _isOutsideThisEl: function (t) { this.el.contains(t) || t === this.el || (gt = null) }, _getDirection: function (t, e) { return "function" == typeof this.options.direction ? this.options.direction.call(this, t, e, q) : this.options.direction }, _onTapStart: function (e) { if (e.cancelable) { var n = this, o = this.el, t = this.options, i = t.preventOnFilter, r = e.type, a = e.touches && e.touches[0] || e.pointerType && "touch" === e.pointerType && e, l = (a || e).target, s = e.target.shadowRoot && (e.path && e.path[0] || e.composedPath && e.composedPath()[0]) || l, c = t.filter; if (!function (t) { Tt.length = 0; var e = t.getElementsByTagName("input"), n = e.length; for (; n--;) { var o = e[n]; o.checked && Tt.push(o) } }(o), !q && !(/mousedown|pointerdown/.test(r) && 0 !== e.button || t.disabled) && !s.isContentEditable && (this.nativeDraggable || !u || !l || "SELECT" !== l.tagName.toUpperCase()) && !((l = N(l, t.draggable, o, !1)) && l.animated || J === l)) { if (nt = B(l), it = B(l, t.draggable), "function" == typeof c) { if (c.call(this, e, l, this)) return U({ sortable: n, rootEl: s, name: "filter", targetEl: l, toEl: o, fromEl: o }), z("filter", n, { evt: e }), void (i && e.cancelable && e.preventDefault()) } else if (c = c && c.split(",").some(function (t) { if (t = N(s, t.trim(), o, !1)) return U({ sortable: n, rootEl: t, name: "filter", targetEl: l, fromEl: o, toEl: o }), z("filter", n, { evt: e }), !0 })) return void (i && e.cancelable && e.preventDefault()); t.handle && !N(s, t.handle, o, !1) || this._prepareDragStart(e, a, l) } } }, _prepareDragStart: function (t, e, n) { var o, i = this, r = i.el, a = i.options, l = r.ownerDocument; n && !q && n.parentNode === r && (o = k(n), $ = r, V = (q = n).parentNode, Q = q.nextSibling, J = n, at = a.group, st = { target: Bt.dragged = q, clientX: (e || t).clientX, clientY: (e || t).clientY }, ht = st.clientX - o.left, ft = st.clientY - o.top, this._lastX = (e || t).clientX, this._lastY = (e || t).clientY, q.style["will-change"] = "all", o = function () { z("delayEnded", i, { evt: t }), Bt.eventCanceled ? i._onDrop() : (i._disableDelayedDragEvents(), !s && i.nativeDraggable && (q.draggable = !0), i._triggerDragStart(t, e), U({ sortable: i, name: "choose", originalEvent: t }), I(q, a.chosenClass, !0)) }, a.ignore.split(",").forEach(function (t) { b(q, t.trim(), jt) }), h(l, "dragover", Xt), h(l, "mousemove", Xt), h(l, "touchmove", Xt), h(l, "mouseup", i._onDrop), h(l, "touchend", i._onDrop), h(l, "touchcancel", i._onDrop), s && this.nativeDraggable && (this.options.touchStartThreshold = 4, q.draggable = !0), z("delayStart", this, { evt: t }), !a.delay || a.delayOnTouchOnly && !e || this.nativeDraggable && (w || y) ? o() : Bt.eventCanceled ? this._onDrop() : (h(l, "mouseup", i._disableDelayedDrag), h(l, "touchend", i._disableDelayedDrag), h(l, "touchcancel", i._disableDelayedDrag), h(l, "mousemove", i._delayedDragTouchMoveHandler), h(l, "touchmove", i._delayedDragTouchMoveHandler), a.supportPointer && h(l, "pointermove", i._delayedDragTouchMoveHandler), i._dragStartTimer = setTimeout(o, a.delay))) }, _delayedDragTouchMoveHandler: function (t) { t = t.touches ? t.touches[0] : t; Math.max(Math.abs(t.clientX - this._lastX), Math.abs(t.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag() }, _disableDelayedDrag: function () { q && jt(q), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents() }, _disableDelayedDragEvents: function () { var t = this.el.ownerDocument; f(t, "mouseup", this._disableDelayedDrag), f(t, "touchend", this._disableDelayedDrag), f(t, "touchcancel", this._disableDelayedDrag), f(t, "mousemove", this._delayedDragTouchMoveHandler), f(t, "touchmove", this._delayedDragTouchMoveHandler), f(t, "pointermove", this._delayedDragTouchMoveHandler) }, _triggerDragStart: function (t, e) { e = e || "touch" == t.pointerType && t, !this.nativeDraggable || e ? this.options.supportPointer ? h(document, "pointermove", this._onTouchMove) : h(document, e ? "touchmove" : "mousemove", this._onTouchMove) : (h(q, "dragend", this), h($, "dragstart", this._onDragStart)); try { document.selection ? Lt(function () { document.selection.empty() }) : window.getSelection().removeAllRanges() } catch (t) { } }, _dragStarted: function (t, e) { var n; yt = !1, $ && q ? (z("dragStarted", this, { evt: e }), this.nativeDraggable && h(document, "dragover", Yt), n = this.options, t || I(q, n.dragClass, !1), I(q, n.ghostClass, !0), Bt.active = this, t && this._appendGhost(), U({ sortable: this, name: "start", originalEvent: e })) : this._nulling() }, _emulateDragOver: function () { if (ct) { this._lastX = ct.clientX, this._lastY = ct.clientY, kt(); for (var t = document.elementFromPoint(ct.clientX, ct.clientY), e = t; t && t.shadowRoot && (t = t.shadowRoot.elementFromPoint(ct.clientX, ct.clientY)) !== e;)e = t; if (q.parentNode[j]._isOutsideThisEl(t), e) do { if (e[j]) if (e[j]._onDragOver({ clientX: ct.clientX, clientY: ct.clientY, target: t, rootEl: e }) && !this.options.dragoverBubble) break } while (e = (t = e).parentNode); Rt() } }, _onTouchMove: function (t) { if (st) { var e = this.options, n = e.fallbackTolerance, o = e.fallbackOffset, i = t.touches ? t.touches[0] : t, r = Z && v(Z, !0), a = Z && r && r.a, l = Z && r && r.d, e = Ot && bt && E(bt), a = (i.clientX - st.clientX + o.x) / (a || 1) + (e ? e[0] - _t[0] : 0) / (a || 1), l = (i.clientY - st.clientY + o.y) / (l || 1) + (e ? e[1] - _t[1] : 0) / (l || 1); if (!Bt.active && !yt) { if (n && Math.max(Math.abs(i.clientX - this._lastX), Math.abs(i.clientY - this._lastY)) < n) return; this._onDragStart(t, !0) } Z && (r ? (r.e += a - (ut || 0), r.f += l - (dt || 0)) : r = { a: 1, b: 0, c: 0, d: 1, e: a, f: l }, r = "matrix(".concat(r.a, ",").concat(r.b, ",").concat(r.c, ",").concat(r.d, ",").concat(r.e, ",").concat(r.f, ")"), P(Z, "webkitTransform", r), P(Z, "mozTransform", r), P(Z, "msTransform", r), P(Z, "transform", r), ut = a, dt = l, ct = i), t.cancelable && t.preventDefault() } }, _appendGhost: function () { if (!Z) { var t = this.options.fallbackOnBody ? document.body : $, e = k(q, !0, Ot, !0, t), n = this.options; if (Ot) { for (bt = t; "static" === P(bt, "position") && "none" === P(bt, "transform") && bt !== document;)bt = bt.parentNode; bt !== document.body && bt !== document.documentElement ? (bt === document && (bt = O()), e.top += bt.scrollTop, e.left += bt.scrollLeft) : bt = O(), _t = E(bt) } I(Z = q.cloneNode(!0), n.ghostClass, !1), I(Z, n.fallbackClass, !0), I(Z, n.dragClass, !0), P(Z, "transition", ""), P(Z, "transform", ""), P(Z, "box-sizing", "border-box"), P(Z, "margin", 0), P(Z, "top", e.top), P(Z, "left", e.left), P(Z, "width", e.width), P(Z, "height", e.height), P(Z, "opacity", "0.8"), P(Z, "position", Ot ? "absolute" : "fixed"), P(Z, "zIndex", "100000"), P(Z, "pointerEvents", "none"), Bt.ghost = Z, t.appendChild(Z), P(Z, "transform-origin", ht / parseInt(Z.style.width) * 100 + "% " + ft / parseInt(Z.style.height) * 100 + "%") } }, _onDragStart: function (t, e) { var n = this, o = t.dataTransfer, i = n.options; z("dragStart", this, { evt: t }), Bt.eventCanceled ? this._onDrop() : (z("setupClone", this), Bt.eventCanceled || ((tt = _(q)).removeAttribute("id"), tt.draggable = !1, tt.style["will-change"] = "", this._hideClone(), I(tt, this.options.chosenClass, !1), Bt.clone = tt), n.cloneId = Lt(function () { z("clone", n), Bt.eventCanceled || (n.options.removeCloneOnHide || $.insertBefore(tt, q), n._hideClone(), U({ sortable: n, name: "clone" })) }), e || I(q, i.dragClass, !0), e ? (wt = !0, n._loopId = setInterval(n._emulateDragOver, 50)) : (f(document, "mouseup", n._onDrop), f(document, "touchend", n._onDrop), f(document, "touchcancel", n._onDrop), o && (o.effectAllowed = "move", i.setData && i.setData.call(n, o, q)), h(document, "drop", n), P(q, "transform", "translateZ(0)")), yt = !0, n._dragStartId = Lt(n._dragStarted.bind(n, e, t)), h(document, "selectstart", n), pt = !0, u && P(document.body, "user-select", "none")) }, _onDragOver: function (n) { var o, i, r, t, a = this.el, l = n.target, e = this.options, s = e.group, c = Bt.active, u = at === s, d = e.sort, h = lt || c, f = this, p = !1; if (!Ct) { if (void 0 !== n.preventDefault && n.cancelable && n.preventDefault(), l = N(l, e.draggable, a, !0), T("dragOver"), Bt.eventCanceled) return p; if (q.contains(n.target) || l.animated && l.animatingX && l.animatingY || f._ignoreWhileAnimating === l) return O(!1); if (wt = !1, c && !e.disabled && (u ? d || (i = V !== $) : lt === this || (this.lastPutMode = at.checkPull(this, c, q, n)) && s.checkPut(this, c, q, n))) { if (r = "vertical" === this._getDirection(n, l), o = k(q), T("dragOverValid"), Bt.eventCanceled) return p; if (i) return V = $, x(), this._hideClone(), T("revert"), Bt.eventCanceled || (Q ? $.insertBefore(q, Q) : $.appendChild(q)), O(!0); var g = Y(a, e.draggable); if (!g || function (t, e, n) { n = k(Y(n.el, n.options.draggable)); return e ? t.clientX > n.right + 10 || t.clientX <= n.right && t.clientY > n.bottom && t.clientX >= n.left : t.clientX > n.right && t.clientY > n.top || t.clientX <= n.right && t.clientY > n.bottom + 10 }(n, r, this) && !g.animated) { if (g === q) return O(!1); if ((l = g && a === n.target ? g : l) && (w = k(l)), !1 !== Ft($, a, q, o, l, w, n, !!l)) return x(), g && g.nextSibling ? a.insertBefore(q, g.nextSibling) : a.appendChild(q), V = a, A(), O(!0) } else if (g && function (t, e, n) { n = k(X(n.el, 0, n.options, !0)); return e ? t.clientX < n.left - 10 || t.clientY < n.top && t.clientX < n.right : t.clientY < n.top - 10 || t.clientY < n.bottom && t.clientX < n.left }(n, r, this)) { var m = X(a, 0, e, !0); if (m === q) return O(!1); if (w = k(l = m), !1 !== Ft($, a, q, o, l, w, n, !1)) return x(), a.insertBefore(q, m), V = a, A(), O(!0) } else if (l.parentNode === a) { var v, b, y, w = k(l), E = q.parentNode !== a, D = (D = q.animated && q.toRect || o, C = l.animated && l.toRect || w, S = (t = r) ? D.left : D.top, s = t ? D.right : D.bottom, g = t ? D.width : D.height, m = t ? C.left : C.top, D = t ? C.right : C.bottom, C = t ? C.width : C.height, !(S === m || s === D || S + g / 2 === m + C / 2)), S = r ? "top" : "left", g = R(l, "top", "top") || R(q, "top", "top"), m = g ? g.scrollTop : void 0; if (gt !== l && (b = w[S], Dt = !1, St = !D && e.invertSwap || E), 0 !== (v = function (t, e, n, o, i, r, a, l) { var s = o ? t.clientY : t.clientX, c = o ? n.height : n.width, t = o ? n.top : n.left, o = o ? n.bottom : n.right, n = !1; if (!a) if (l && vt < c * i) { if (Dt = !Dt && (1 === mt ? t + c * r / 2 < s : s < o - c * r / 2) ? !0 : Dt) n = !0; else if (1 === mt ? s < t + vt : o - vt < s) return -mt } else if (t + c * (1 - i) / 2 < s && s < o - c * (1 - i) / 2) return function (t) { return B(q) < B(t) ? 1 : -1 }(e); if ((n = n || a) && (s < t + c * r / 2 || o - c * r / 2 < s)) return t + c / 2 < s ? 1 : -1; return 0 }(n, l, w, r, D ? 1 : e.swapThreshold, null == e.invertedSwapThreshold ? e.swapThreshold : e.invertedSwapThreshold, St, gt === l))) for (var _ = B(q); (y = V.children[_ -= v]) && ("none" === P(y, "display") || y === Z);); if (0 === v || y === l) return O(!1); mt = v; var C = (gt = l).nextElementSibling, E = !1, D = Ft($, a, q, o, l, w, n, E = 1 === v); if (!1 !== D) return 1 !== D && -1 !== D || (E = 1 === D), Ct = !0, setTimeout(Ht, 30), x(), E && !C ? a.appendChild(q) : l.parentNode.insertBefore(q, E ? C : l), g && F(g, 0, m - g.scrollTop), V = q.parentNode, void 0 === b || St || (vt = Math.abs(b - k(l)[S])), A(), O(!0) } if (a.contains(q)) return O(!1) } return !1 } function T(t, e) { z(t, f, M({ evt: n, isOwner: u, axis: r ? "vertical" : "horizontal", revert: i, dragRect: o, targetRect: w, canSort: d, fromSortable: h, target: l, completed: O, onMove: function (t, e) { return Ft($, a, q, o, t, k(t), n, e) }, changed: A }, e)) } function x() { T("dragOverAnimationCapture"), f.captureAnimationState(), f !== h && h.captureAnimationState() } function O(t) { return T("dragOverCompleted", { insertion: t }), t && (u ? c._hideClone() : c._showClone(f), f !== h && (I(q, (lt || c).options.ghostClass, !1), I(q, e.ghostClass, !0)), lt !== f && f !== Bt.active ? lt = f : f === Bt.active && lt && (lt = null), h === f && (f._ignoreWhileAnimating = l), f.animateAll(function () { T("dragOverAnimationComplete"), f._ignoreWhileAnimating = null }), f !== h && (h.animateAll(), h._ignoreWhileAnimating = null)), (l === q && !q.animated || l === a && !l.animated) && (gt = null), e.dragoverBubble || n.rootEl || l === document || (q.parentNode[j]._isOutsideThisEl(n.target), t || Xt(n)), !e.dragoverBubble && n.stopPropagation && n.stopPropagation(), p = !0 } function A() { ot = B(q), rt = B(q, e.draggable), U({ sortable: f, name: "change", toEl: a, newIndex: ot, newDraggableIndex: rt, originalEvent: n }) } }, _ignoreWhileAnimating: null, _offMoveEvents: function () { f(document, "mousemove", this._onTouchMove), f(document, "touchmove", this._onTouchMove), f(document, "pointermove", this._onTouchMove), f(document, "dragover", Xt), f(document, "mousemove", Xt), f(document, "touchmove", Xt) }, _offUpEvents: function () { var t = this.el.ownerDocument; f(t, "mouseup", this._onDrop), f(t, "touchend", this._onDrop), f(t, "pointerup", this._onDrop), f(t, "touchcancel", this._onDrop), f(document, "selectstart", this) }, _onDrop: function (t) { var e = this.el, n = this.options; ot = B(q), rt = B(q, n.draggable), z("drop", this, { evt: t }), V = q && q.parentNode, ot = B(q), rt = B(q, n.draggable), Bt.eventCanceled || (Dt = St = yt = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), Kt(this.cloneId), Kt(this._dragStartId), this.nativeDraggable && (f(document, "drop", this), f(e, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), u && P(document.body, "user-select", ""), P(q, "transform", ""), t && (pt && (t.cancelable && t.preventDefault(), n.dropBubble || t.stopPropagation()), Z && Z.parentNode && Z.parentNode.removeChild(Z), ($ === V || lt && "clone" !== lt.lastPutMode) && tt && tt.parentNode && tt.parentNode.removeChild(tt), q && (this.nativeDraggable && f(q, "dragend", this), jt(q), q.style["will-change"] = "", pt && !yt && I(q, (lt || this).options.ghostClass, !1), I(q, this.options.chosenClass, !1), U({ sortable: this, name: "unchoose", toEl: V, newIndex: null, newDraggableIndex: null, originalEvent: t }), $ !== V ? (0 <= ot && (U({ rootEl: V, name: "add", toEl: V, fromEl: $, originalEvent: t }), U({ sortable: this, name: "remove", toEl: V, originalEvent: t }), U({ rootEl: V, name: "sort", toEl: V, fromEl: $, originalEvent: t }), U({ sortable: this, name: "sort", toEl: V, originalEvent: t })), lt && lt.save()) : ot !== nt && 0 <= ot && (U({ sortable: this, name: "update", toEl: V, originalEvent: t }), U({ sortable: this, name: "sort", toEl: V, originalEvent: t })), Bt.active && (null != ot && -1 !== ot || (ot = nt, rt = it), U({ sortable: this, name: "end", toEl: V, originalEvent: t }), this.save())))), this._nulling() }, _nulling: function () { z("nulling", this), $ = q = V = Z = Q = tt = J = et = st = ct = pt = ot = rt = nt = it = gt = mt = lt = at = Bt.dragged = Bt.ghost = Bt.clone = Bt.active = null, Tt.forEach(function (t) { t.checked = !0 }), Tt.length = ut = dt = 0 }, handleEvent: function (t) { switch (t.type) { case "drop": case "dragend": this._onDrop(t); break; case "dragenter": case "dragover": q && (this._onDragOver(t), function (t) { t.dataTransfer && (t.dataTransfer.dropEffect = "move"); t.cancelable && t.preventDefault() }(t)); break; case "selectstart": t.preventDefault() } }, toArray: function () { for (var t, e = [], n = this.el.children, o = 0, i = n.length, r = this.options; o < i; o++)N(t = n[o], r.draggable, this.el, !1) && e.push(t.getAttribute(r.dataIdAttr) || function (t) { var e = t.tagName + t.className + t.src + t.href + t.textContent, n = e.length, o = 0; for (; n--;)o += e.charCodeAt(n); return o.toString(36) }(t)); return e }, sort: function (t, e) { var n = {}, o = this.el; this.toArray().forEach(function (t, e) { e = o.children[e]; N(e, this.options.draggable, o, !1) && (n[t] = e) }, this), e && this.captureAnimationState(), t.forEach(function (t) { n[t] && (o.removeChild(n[t]), o.appendChild(n[t])) }), e && this.animateAll() }, save: function () { var t = this.options.store; t && t.set && t.set(this) }, closest: function (t, e) { return N(t, e || this.options.draggable, this.el, !1) }, option: function (t, e) { var n = this.options; if (void 0 === e) return n[t]; var o = K.modifyOption(this, t, e); n[t] = void 0 !== o ? o : e, "group" === t && Pt(n) }, destroy: function () { z("destroy", this); var t = this.el; t[j] = null, f(t, "mousedown", this._onTapStart), f(t, "touchstart", this._onTapStart), f(t, "pointerdown", this._onTapStart), this.nativeDraggable && (f(t, "dragover", this), f(t, "dragenter", this)), Array.prototype.forEach.call(t.querySelectorAll("[draggable]"), function (t) { t.removeAttribute("draggable") }), this._onDrop(), this._disableDelayedDragEvents(), Et.splice(Et.indexOf(this.el), 1), this.el = t = null }, _hideClone: function () { et || (z("hideClone", this), Bt.eventCanceled || (P(tt, "display", "none"), this.options.removeCloneOnHide && tt.parentNode && tt.parentNode.removeChild(tt), et = !0)) }, _showClone: function (t) { "clone" === t.lastPutMode ? et && (z("showClone", this), Bt.eventCanceled || (q.parentNode != $ || this.options.group.revertClone ? Q ? $.insertBefore(tt, Q) : $.appendChild(tt) : $.insertBefore(tt, q), this.options.group.revertClone && this.animate(q, tt), P(tt, "display", ""), et = !1)) : this._hideClone() } }, xt && h(document, "touchmove", function (t) { (Bt.active || yt) && t.cancelable && t.preventDefault() }), Bt.utils = { on: h, off: f, css: P, find: b, is: function (t, e) { return !!N(t, e, t, !1) }, extend: function (t, e) { if (t && e) for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]); return t }, throttle: S, closest: N, toggleClass: I, clone: _, index: B, nextTick: Lt, cancelNextTick: Kt, detectDirection: It, getChild: X }, Bt.get = function (t) { return t[j] }, Bt.mount = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; (e = e[0].constructor === Array ? e[0] : e).forEach(function (t) { if (!t.prototype || !t.prototype.constructor) throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(t)); t.utils && (Bt.utils = M(M({}, Bt.utils), t.utils)), K.mount(t) }) }, Bt.create = function (t, e) { return new Bt(t, e) }; var Wt, zt, Gt, Ut, qt, Vt, Zt = [], $t = !(Bt.version = "1.15.0"); function Qt() { Zt.forEach(function (t) { clearInterval(t.pid) }), Zt = [] } function Jt() { clearInterval(Vt) } var te, ee = S(function (n, t, e, o) { if (t.scroll) { var i, r = (n.touches ? n.touches[0] : n).clientX, a = (n.touches ? n.touches[0] : n).clientY, l = t.scrollSensitivity, s = t.scrollSpeed, c = O(), u = !1; zt !== e && (zt = e, Qt(), Wt = t.scroll, i = t.scrollFn, !0 === Wt && (Wt = A(e, !0))); var d = 0, h = Wt; do { var f = h, p = k(f), g = p.top, m = p.bottom, v = p.left, b = p.right, y = p.width, w = p.height, E = void 0, D = void 0, S = f.scrollWidth, _ = f.scrollHeight, C = P(f), T = f.scrollLeft, p = f.scrollTop, D = f === c ? (E = y < S && ("auto" === C.overflowX || "scroll" === C.overflowX || "visible" === C.overflowX), w < _ && ("auto" === C.overflowY || "scroll" === C.overflowY || "visible" === C.overflowY)) : (E = y < S && ("auto" === C.overflowX || "scroll" === C.overflowX), w < _ && ("auto" === C.overflowY || "scroll" === C.overflowY)), T = E && (Math.abs(b - r) <= l && T + y < S) - (Math.abs(v - r) <= l && !!T), p = D && (Math.abs(m - a) <= l && p + w < _) - (Math.abs(g - a) <= l && !!p); if (!Zt[d]) for (var x = 0; x <= d; x++)Zt[x] || (Zt[x] = {}); Zt[d].vx == T && Zt[d].vy == p && Zt[d].el === f || (Zt[d].el = f, Zt[d].vx = T, Zt[d].vy = p, clearInterval(Zt[d].pid), 0 == T && 0 == p || (u = !0, Zt[d].pid = setInterval(function () { o && 0 === this.layer && Bt.active._onTouchMove(qt); var t = Zt[this.layer].vy ? Zt[this.layer].vy * s : 0, e = Zt[this.layer].vx ? Zt[this.layer].vx * s : 0; "function" == typeof i && "continue" !== i.call(Bt.dragged.parentNode[j], e, t, n, qt, Zt[this.layer].el) || F(Zt[this.layer].el, e, t) }.bind({ layer: d }), 24))), d++ } while (t.bubbleScroll && h !== c && (h = A(h, !1))); $t = u } }, 30), c = function (t) { var e = t.originalEvent, n = t.putSortable, o = t.dragEl, i = t.activeSortable, r = t.dispatchSortableEvent, a = t.hideGhostForTarget, t = t.unhideGhostForTarget; e && (i = n || i, a(), e = e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : e, e = document.elementFromPoint(e.clientX, e.clientY), t(), i && !i.el.contains(e) && (r("spill"), this.onSpill({ dragEl: o, putSortable: n }))) }; function ne() { } function oe() { } ne.prototype = { startIndex: null, dragStart: function (t) { t = t.oldDraggableIndex; this.startIndex = t }, onSpill: function (t) { var e = t.dragEl, n = t.putSortable; this.sortable.captureAnimationState(), n && n.captureAnimationState(); t = X(this.sortable.el, this.startIndex, this.options); t ? this.sortable.el.insertBefore(e, t) : this.sortable.el.appendChild(e), this.sortable.animateAll(), n && n.animateAll() }, drop: c }, a(ne, { pluginName: "revertOnSpill" }), oe.prototype = { onSpill: function (t) { var e = t.dragEl, t = t.putSortable || this.sortable; t.captureAnimationState(), e.parentNode && e.parentNode.removeChild(e), t.animateAll() }, drop: c }, a(oe, { pluginName: "removeOnSpill" }); var ie, re, ae, le, se, ce = [], ue = [], de = !1, he = !1, fe = !1; function pe(n, o) { ue.forEach(function (t, e) { e = o.children[t.sortableIndex + (n ? Number(e) : 0)]; e ? o.insertBefore(t, e) : o.appendChild(t) }) } function ge() { ce.forEach(function (t) { t !== ae && t.parentNode && t.parentNode.removeChild(t) }) } return Bt.mount(new function () { function t() { for (var t in this.defaults = { scroll: !0, forceAutoScrollFallback: !1, scrollSensitivity: 30, scrollSpeed: 10, bubbleScroll: !0 }, this) "_" === t.charAt(0) && "function" == typeof this[t] && (this[t] = this[t].bind(this)) } return t.prototype = { dragStarted: function (t) { t = t.originalEvent; this.sortable.nativeDraggable ? h(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? h(document, "pointermove", this._handleFallbackAutoScroll) : t.touches ? h(document, "touchmove", this._handleFallbackAutoScroll) : h(document, "mousemove", this._handleFallbackAutoScroll) }, dragOverCompleted: function (t) { t = t.originalEvent; this.options.dragOverBubble || t.rootEl || this._handleAutoScroll(t) }, drop: function () { this.sortable.nativeDraggable ? f(document, "dragover", this._handleAutoScroll) : (f(document, "pointermove", this._handleFallbackAutoScroll), f(document, "touchmove", this._handleFallbackAutoScroll), f(document, "mousemove", this._handleFallbackAutoScroll)), Jt(), Qt(), clearTimeout(g), g = void 0 }, nulling: function () { qt = zt = Wt = $t = Vt = Gt = Ut = null, Zt.length = 0 }, _handleFallbackAutoScroll: function (t) { this._handleAutoScroll(t, !0) }, _handleAutoScroll: function (e, n) { var o, i = this, r = (e.touches ? e.touches[0] : e).clientX, a = (e.touches ? e.touches[0] : e).clientY, t = document.elementFromPoint(r, a); qt = e, n || this.options.forceAutoScrollFallback || w || y || u ? (ee(e, this.options, t, n), o = A(t, !0), !$t || Vt && r === Gt && a === Ut || (Vt && Jt(), Vt = setInterval(function () { var t = A(document.elementFromPoint(r, a), !0); t !== o && (o = t, Qt()), ee(e, i.options, t, n) }, 10), Gt = r, Ut = a)) : this.options.bubbleScroll && A(t, !0) !== O() ? ee(e, this.options, A(t, !1), !1) : Qt() } }, a(t, { pluginName: "scroll", initializeByDefault: !0 }) }), Bt.mount(oe, ne), Bt.mount(new function () { function t() { this.defaults = { swapClass: "sortable-swap-highlight" } } return t.prototype = { dragStart: function (t) { t = t.dragEl; te = t }, dragOverValid: function (t) { var e = t.completed, n = t.target, o = t.onMove, i = t.activeSortable, r = t.changed, a = t.cancel; i.options.swap && (t = this.sortable.el, i = this.options, n && n !== t && (t = te, te = !1 !== o(n) ? (I(n, i.swapClass, !0), n) : null, t && t !== te && I(t, i.swapClass, !1)), r(), e(!0), a()) }, drop: function (t) { var e, n, o = t.activeSortable, i = t.putSortable, r = t.dragEl, a = i || this.sortable, l = this.options; te && I(te, l.swapClass, !1), te && (l.swap || i && i.options.swap) && r !== te && (a.captureAnimationState(), a !== o && o.captureAnimationState(), n = te, t = (e = r).parentNode, l = n.parentNode, t && l && !t.isEqualNode(n) && !l.isEqualNode(e) && (i = B(e), r = B(n), t.isEqualNode(l) && i < r && r++, t.insertBefore(n, t.children[i]), l.insertBefore(e, l.children[r])), a.animateAll(), a !== o && o.animateAll()) }, nulling: function () { te = null } }, a(t, { pluginName: "swap", eventProperties: function () { return { swapItem: te } } }) }), Bt.mount(new function () { function t(o) { for (var t in this) "_" === t.charAt(0) && "function" == typeof this[t] && (this[t] = this[t].bind(this)); o.options.avoidImplicitDeselect || (o.options.supportPointer ? h(document, "pointerup", this._deselectMultiDrag) : (h(document, "mouseup", this._deselectMultiDrag), h(document, "touchend", this._deselectMultiDrag))), h(document, "keydown", this._checkKeyDown), h(document, "keyup", this._checkKeyUp), this.defaults = { selectedClass: "sortable-selected", multiDragKey: null, avoidImplicitDeselect: !1, setData: function (t, e) { var n = ""; ce.length && re === o ? ce.forEach(function (t, e) { n += (e ? ", " : "") + t.textContent }) : n = e.textContent, t.setData("Text", n) } } } return t.prototype = { multiDragKeyDown: !1, isMultiDrag: !1, delayStartGlobal: function (t) { t = t.dragEl; ae = t }, delayEnded: function () { this.isMultiDrag = ~ce.indexOf(ae) }, setupClone: function (t) { var e = t.sortable, t = t.cancel; if (this.isMultiDrag) { for (var n = 0; n < ce.length; n++)ue.push(_(ce[n])), ue[n].sortableIndex = ce[n].sortableIndex, ue[n].draggable = !1, ue[n].style["will-change"] = "", I(ue[n], this.options.selectedClass, !1), ce[n] === ae && I(ue[n], this.options.chosenClass, !1); e._hideClone(), t() } }, clone: function (t) { var e = t.sortable, n = t.rootEl, o = t.dispatchSortableEvent, t = t.cancel; this.isMultiDrag && (this.options.removeCloneOnHide || ce.length && re === e && (pe(!0, n), o("clone"), t())) }, showClone: function (t) { var e = t.cloneNowShown, n = t.rootEl, t = t.cancel; this.isMultiDrag && (pe(!1, n), ue.forEach(function (t) { P(t, "display", "") }), e(), se = !1, t()) }, hideClone: function (t) { var e = this, n = (t.sortable, t.cloneNowHidden), t = t.cancel; this.isMultiDrag && (ue.forEach(function (t) { P(t, "display", "none"), e.options.removeCloneOnHide && t.parentNode && t.parentNode.removeChild(t) }), n(), se = !0, t()) }, dragStartGlobal: function (t) { t.sortable; !this.isMultiDrag && re && re.multiDrag._deselectMultiDrag(), ce.forEach(function (t) { t.sortableIndex = B(t) }), ce = ce.sort(function (t, e) { return t.sortableIndex - e.sortableIndex }), fe = !0 }, dragStarted: function (t) { var e, n = this, t = t.sortable; this.isMultiDrag && (this.options.sort && (t.captureAnimationState(), this.options.animation && (ce.forEach(function (t) { t !== ae && P(t, "position", "absolute") }), e = k(ae, !1, !0, !0), ce.forEach(function (t) { t !== ae && C(t, e) }), de = he = !0)), t.animateAll(function () { de = he = !1, n.options.animation && ce.forEach(function (t) { T(t) }), n.options.sort && ge() })) }, dragOver: function (t) { var e = t.target, n = t.completed, t = t.cancel; he && ~ce.indexOf(e) && (n(!1), t()) }, revert: function (t) { var n, o, e = t.fromSortable, i = t.rootEl, r = t.sortable, a = t.dragRect; 1 < ce.length && (ce.forEach(function (t) { r.addAnimationState({ target: t, rect: he ? k(t) : a }), T(t), t.fromRect = a, e.removeAnimationState(t) }), he = !1, n = !this.options.removeCloneOnHide, o = i, ce.forEach(function (t, e) { e = o.children[t.sortableIndex + (n ? Number(e) : 0)]; e ? o.insertBefore(t, e) : o.appendChild(t) })) }, dragOverCompleted: function (t) { var e, n = t.sortable, o = t.isOwner, i = t.insertion, r = t.activeSortable, a = t.parentEl, l = t.putSortable, t = this.options; i && (o && r._hideClone(), de = !1, t.animation && 1 < ce.length && (he || !o && !r.options.sort && !l) && (e = k(ae, !1, !0, !0), ce.forEach(function (t) { t !== ae && (C(t, e), a.appendChild(t)) }), he = !0), o || (he || ge(), 1 < ce.length ? (o = se, r._showClone(n), r.options.animation && !se && o && ue.forEach(function (t) { r.addAnimationState({ target: t, rect: le }), t.fromRect = le, t.thisAnimationDuration = null })) : r._showClone(n))) }, dragOverAnimationCapture: function (t) { var e = t.dragRect, n = t.isOwner, t = t.activeSortable; ce.forEach(function (t) { t.thisAnimationDuration = null }), t.options.animation && !n && t.multiDrag.isMultiDrag && (le = a({}, e), e = v(ae, !0), le.top -= e.f, le.left -= e.e) }, dragOverAnimationComplete: function () { he && (he = !1, ge()) }, drop: function (t) { var e = t.originalEvent, n = t.rootEl, o = t.parentEl, i = t.sortable, r = t.dispatchSortableEvent, a = t.oldIndex, l = t.putSortable, s = l || this.sortable; if (e) { var c, u, d, h = this.options, f = o.children; if (!fe) if (h.multiDragKey && !this.multiDragKeyDown && this._deselectMultiDrag(), I(ae, h.selectedClass, !~ce.indexOf(ae)), ~ce.indexOf(ae)) ce.splice(ce.indexOf(ae), 1), ie = null, W({ sortable: i, rootEl: n, name: "deselect", targetEl: ae, originalEvent: e }); else { if (ce.push(ae), W({ sortable: i, rootEl: n, name: "select", targetEl: ae, originalEvent: e }), e.shiftKey && ie && i.el.contains(ie)) { var p = B(ie), t = B(ae); if (~p && ~t && p !== t) for (var g, m = p < t ? (g = p, t) : (g = t, p + 1); g < m; g++)~ce.indexOf(f[g]) || (I(f[g], h.selectedClass, !0), ce.push(f[g]), W({ sortable: i, rootEl: n, name: "select", targetEl: f[g], originalEvent: e })) } else ie = ae; re = s } fe && this.isMultiDrag && (he = !1, (o[j].options.sort || o !== n) && 1 < ce.length && (c = k(ae), u = B(ae, ":not(." + this.options.selectedClass + ")"), !de && h.animation && (ae.thisAnimationDuration = null), s.captureAnimationState(), de || (h.animation && (ae.fromRect = c, ce.forEach(function (t) { var e; t.thisAnimationDuration = null, t !== ae && (e = he ? k(t) : c, t.fromRect = e, s.addAnimationState({ target: t, rect: e })) })), ge(), ce.forEach(function (t) { f[u] ? o.insertBefore(t, f[u]) : o.appendChild(t), u++ }), a === B(ae) && (d = !1, ce.forEach(function (t) { t.sortableIndex !== B(t) && (d = !0) }), d && r("update"))), ce.forEach(function (t) { T(t) }), s.animateAll()), re = s), (n === o || l && "clone" !== l.lastPutMode) && ue.forEach(function (t) { t.parentNode && t.parentNode.removeChild(t) }) } }, nullingGlobal: function () { this.isMultiDrag = fe = !1, ue.length = 0 }, destroyGlobal: function () { this._deselectMultiDrag(), f(document, "pointerup", this._deselectMultiDrag), f(document, "mouseup", this._deselectMultiDrag), f(document, "touchend", this._deselectMultiDrag), f(document, "keydown", this._checkKeyDown), f(document, "keyup", this._checkKeyUp) }, _deselectMultiDrag: function (t) { if (!(void 0 !== fe && fe || re !== this.sortable || t && N(t.target, this.options.draggable, this.sortable.el, !1) || t && 0 !== t.button)) for (; ce.length;) { var e = ce[0]; I(e, this.options.selectedClass, !1), ce.shift(), W({ sortable: this.sortable, rootEl: this.sortable.el, name: "deselect", targetEl: e, originalEvent: t }) } }, _checkKeyDown: function (t) { t.key === this.options.multiDragKey && (this.multiDragKeyDown = !0) }, _checkKeyUp: function (t) { t.key === this.options.multiDragKey && (this.multiDragKeyDown = !1) } }, a(t, { pluginName: "multiDrag", utils: { select: function (t) { var e = t.parentNode[j]; e && e.options.multiDrag && !~ce.indexOf(t) && (re && re !== e && (re.multiDrag._deselectMultiDrag(), re = e), I(t, e.options.selectedClass, !0), ce.push(t)) }, deselect: function (t) { var e = t.parentNode[j], n = ce.indexOf(t); e && e.options.multiDrag && ~n && (I(t, e.options.selectedClass, !1), ce.splice(n, 1)) } }, eventProperties: function () { var n = this, o = [], i = []; return ce.forEach(function (t) { var e; o.push({ multiDragElement: t, index: t.sortableIndex }), e = he && t !== ae ? -1 : he ? B(t, ":not(." + n.options.selectedClass + ")") : B(t), i.push({ multiDragElement: t, index: e }) }), { items: r(ce), clones: [].concat(ue), oldIndicies: o, newIndicies: i } }, optionListeners: { multiDragKey: function (t) { return "ctrl" === (t = t.toLowerCase()) ? t = "Control" : 1 < t.length && (t = t.charAt(0).toUpperCase() + t.substr(1)), t } } }) }), Bt });
    </script>
</head>

<body>
    <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="#">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->
    <div class="main_nav">
        <div class="dropdown">
            <button>File</button>
            <div class="dropdown-content">
                <a onclick="selLclFile()">Open</a>
                <a onclick="saveAsLclFile()">Save As</a>
            </div>
        </div>
        <div class="dropdown">
            <button onclick="toggleSettings()">Settings</button>
        </div>
    </div>

    <div class="panels">
        <div class="editor_tools panel">
            <div class="realLabel">Applied effects</div>
            <div id="effectlist">
                <div class="effectinlist">
                    <div class="label">Blur</div>
                    <div class="handle material-symbols-rounded">drag_indicator</div>
                </div>
            </div>
        </div>
        <div class="output_panel">
            <canvas id="canvas"></canvas>
        </div>
        <div class="effects_panel panel">
            <div class="effects_grid">
            </div>
            <div class="seperator"></div>
            <div id="effect_tools">
                <div class="label">
                    hue
                </div>
                <input type="range">
            </div>
        </div>
        <img id="source"
            src="data:image/svg+xml,%3Csvg id='html5' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='50' height='50' viewBox='0 0 50 50' enable-background='new 0 0 50 50' xml:space='preserve'%3E%3Ctitle%3EHTML5 Logo%3C/title%3E%3Cpath id='shield' fill='%23E34F26' d='M6.5,44.9L2.5,0h44l-4,44.9L24.5,50'/%3E%3Cpath id='shield-light' fill='%23EF652A' d='M24.5,46.1l14.6-4l3.4-38.5h-18'/%3E%3Cpath id='five-shadow' fill='%23EBEBEB' d='M24.5,20.3h-7.3l-0.5-5.7h7.8V9.2h-0.1H10.7l0.1,1.5l1.4,15.2h12.4V20.3z M24.5,34.7 L24.5,34.7L18.3,33l-0.4-4.4H15h-2.5l0.7,8.7l11.3,3.1h0.1V34.7z'/%3E%3Cpath id='five' fill='%23FFFFFF' d='M24.5,20.3v5.6h6.8L30.6,33l-6.2,1.7v5.8l11.3-3.1l0.1-1l1.3-14.6l0.2-1.5h-1.6H24.5z M24.5,9.2 v3.4v2.1l0,0h13.4l0,0l0,0l0.1-1.2l0.3-2.8l0.1-1.5H24.5z'/%3E%3C/svg%3E"
            style="display:none;" />
    </div>

    <div class="dialog_window" id="settingswindow">
        <div class="content">
            <div class="header">
                <div class="title">Settings</div>
                <div class="clbtn material-symbols-rounded" onclick="window.toggleSettings()">done</div>
            </div>
            <div id="settings_list">
                <div class="setting">
                    <div class="text_part">
                        <div class="title">Output FPS</div>
                        <p>Configure how frequently the output gets rendered. Affects performance.</p>
                    </div>
                    <input settingdata="result_fps" class="singular_setting" placeholder="30" value="30">
                </div>
            </div>

        </div>

    </div>
    <script defer>
        async function selLclFile() {
            const fileID = await ntxSession.send("olp.useHandler", "file_manager", { "opener": 'any', "dir": "Downloads/" });
            sourceImage.src = (await window.parent.getFileById(fileID)).content;
        }

        async function saveAsLclFile() {
            let toBeSavedToData = await ntxSession.send("olp.useHandler", "file_manager", { "opener": 'saveas', "value": "exported "+window.parent.genUID()+".webp" });
            const dataUri = eff.state.ctx.canvas.toDataURL('image/webp');
            await ntxSession.send("fileSet.createFile", toBeSavedToData.path, toBeSavedToData.name, false, dataUri);
        }

        const sourceImage = document.getElementById('source');
        sourceImage.onload = () => {
            rangeInit();
            eff.initializeCanvas();

            const effectsGrid = document.querySelector('.effects_grid');
            effectsGrid.innerHTML = "";

            Object.keys(eff.effectslib).forEach(key => {
                let singularEffectBtn = document.createElement('div');
                singularEffectBtn.className = 'singular_effect_btn';

                let iconDiv = document.createElement('div');
                iconDiv.className = 'icon material-symbols-rounded';
                iconDiv.textContent = eff.effectslib[key].icon;

                let labelDiv = document.createElement('div');
                labelDiv.className = 'label';
                labelDiv.textContent = key.charAt(0).toUpperCase() + key.slice(1);

                singularEffectBtn.appendChild(iconDiv);
                singularEffectBtn.appendChild(labelDiv);
                singularEffectBtn.addEventListener("click", () => {
                    renderEffectTools(key, singularEffectBtn);
                })
                effectsGrid.appendChild(singularEffectBtn);
            });
        };

        if (sourceImage.complete) {
            sourceImage.onload();
        }
        function renderEffectTools(key, ele) {
            Array.from(document.getElementsByClassName("singular_effect_btn")).forEach((x) => {
                x.classList.remove("active");
            });

            ele.classList.add("active");

            var container = document.getElementById("effect_tools");
            container.innerHTML = "";

            var category = eff.effectslib[key];
            if (!category) return;

            Object.keys(category).forEach(function (subKey) {
                var effectFunc = category[subKey];
                if (typeof effectFunc !== "function") return;

                var meta = effectFunc._meta || {};

                var label = document.createElement("div");
                label.className = "label";
                label.textContent = meta.label || subKey;
                container.appendChild(label);

                if (meta.type === "range") {
                    var input = document.createElement("input");
                    input.type = "range";
                    input.min = meta.min ?? 0;
                    input.max = meta.max ?? 100;
                    input.step = meta.step ?? 1;
                    input.value = meta.default ?? 0;

                    if (meta.nosnap) {
                        input.setAttribute("data-nosnap", "");
                    }

                    input.addEventListener("input", function () {
                        var value = parseFloat(this.value);

                        var existing = eff.state.appliedEffects.find(e => e.categoryKey === key && e.effectKey === subKey);
                        if (existing) {
                            existing.value = value;
                        } else {
                            eff.state.appliedEffects.push({ categoryKey: key, effectKey: subKey, value: value });
                        }

                        renderImage();
                    });

                    container.appendChild(input);

                } else if (meta.type === "button") {
                    var btn = document.createElement("button");
                    btn.textContent = meta.label || subKey;

                    btn.addEventListener("click", function () {
                        eff.state.appliedEffects.push({ categoryKey: key, effectKey: subKey });
                        renderImage();
                    });

                    container.appendChild(btn);
                }
            });

            rangeInit();
        }

        let lastRenderTime = 0;

        function renderImage() {
            let frameInterval = 1000 / GSetting.result_fps;
            const now = Date.now();
            if (now - lastRenderTime < frameInterval) return;
            lastRenderTime = now;

            if (!eff.state.originalImage) return;
            eff.state.ctx.clearRect(0, 0, eff.state.canvas.width, eff.state.canvas.height);
            eff.state.ctx.drawImage(eff.state.originalImage, 0, 0, eff.state.canvas.width, eff.state.canvas.height);
            console.log(eff.state.appliedEffects);

            eff.state.appliedEffects.forEach(({ categoryKey, effectKey, value }) => {
                var effectGroup = eff.effectslib[categoryKey];
                if (!effectGroup) return;

                var effectFunc = effectGroup[effectKey];
                if (typeof effectFunc !== "function") return;

                if (value !== undefined) {
                    effectFunc(value);
                } else {
                    effectFunc();
                }
            });
            renderEffectsList()
        }

        function renderEffectsList() {
            const list = document.getElementById('effectlist');
            list.innerHTML = '';
            eff.state.appliedEffects.forEach((effect, index) => {
                const item = document.createElement('div');
                item.className = 'effectinlist';
                item.setAttribute('data-index', index);

                const label = document.createElement('div');
                label.className = 'label';
                label.textContent = effect.effectKey;

                const handle = document.createElement('div');
                handle.className = 'handle material-symbols-rounded';
                handle.textContent = 'drag_indicator';

                item.appendChild(label);
                item.appendChild(handle);
                list.appendChild(item);
            });
        }

        Sortable.create(document.getElementById('effectlist'), {
            handle: '.handle',
            animation: 150,
            onEnd: function (evt) {
                const newOrder = Array.from(document.querySelectorAll('.effectinlist'))
                    .map(el => parseInt(el.getAttribute('data-index')));

                const reordered = newOrder.map(i => eff.state.appliedEffects[i]);
                eff.state.appliedEffects = reordered;

                renderEffectsList();
                renderImage();
            }
        });

        var settingsmodal = document.getElementById("settingswindow");
        settingsmodal.addEventListener("click", (e) => {
            if (!e.target.closest('.content')) {
                settingsmodal.style.display = "none";
                settingsopen = 0;
            }
        });

        var settingsopen = 0;
        window.toggleSettings = function () {
            if (settingsopen) {
                settingsmodal.style.display = "none";
                settingsopen = 0;
                applySettings();
            } else {
                settingsmodal.style.display = "flex";
                settingsopen = 1;
            }
        }
        window.GSetting = {
            "result_fps": 30
        }
        function applySettings() {
            var elements = document.querySelectorAll(".singular_setting");
            elements.forEach((x) => {
                let key = x.getAttribute("settingdata");
                GSetting[key] = parseInt(x.value);
            })
        }
    </script>
</body>

</html>